---
// GourmetChat.astro - ã‚°ãƒ«ãƒ¡ã‚µãƒãƒ¼ãƒˆãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export interface Props {
  apiBaseUrl?: string;
}

const { apiBaseUrl = '' } = Astro.props;
---

<div class="gourmet-chat-container" data-api-base={apiBaseUrl}>
  <div class="splash-overlay" id="splashOverlay">
    <video
      id="splashVideo"
      class="splash-video"
      autoplay
      muted
      playsinline
      loop
    >
      <source src="/splash.mp4" type="video/mp4">
    </video>
    <div class="splash-loading">
      <div class="spinner"></div>
      <p>æº–å‚™ä¸­...</p>
    </div>
  </div>

  <div class="wait-overlay hidden" id="waitOverlay">
    <div class="wait-content">
      <video id="waitVideo" class="wait-video" muted playsinline loop>
        <source src="/wait.mp4" type="video/mp4">
      </video>
      <p class="wait-text">AIãŒãŠåº—ã‚’æ¤œç´¢ã—ã¦ã„ã¾ã™...</p>
    </div>
  </div>

  <div class="language-selector">
    <select id="languageSelect" class="language-dropdown">
      <option value="ja">æ—¥æœ¬èª (Japanese)</option>
      <option value="en">English</option>
      <option value="zh">ä¸­æ–‡ (Chinese)</option>
      <option value="ko">í•œêµ­ì–´ (Korean)</option>
    </select>
  </div>

  <div class="voice-status stopped" id="voiceStatus">
    ğŸ¤ éŸ³å£°èªè­˜: åœæ­¢ä¸­
  </div>

  <div class="chat-area" id="chatArea">
    </div>

  <div class="input-area">
    <div class="input-group">
      <input
        type="text"
        id="userInput"
        placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›..."
        disabled
      />
      <button class="btn btn-icon btn-mic" id="micBtn" title="éŸ³å£°å…¥åŠ›" disabled>
        ğŸ¤
      </button>
      <button class="btn btn-icon btn-speaker" id="speakerBtn" title="éŸ³å£°èª­ã¿ä¸Šã’ON" disabled>
        ğŸ”Š
      </button>
      <button class="btn" id="sendBtn" disabled>
        é€ä¿¡
      </button>
    </div>
    <div class="input-actions">
      <button class="btn btn-reservation" id="reservationBtn" disabled>
        ğŸ“ äºˆç´„ä¾é ¼ã™ã‚‹
      </button>
    </div>
  </div>
</div>

<style>
  .gourmet-chat-container {
    background: white;
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
    width: 100%;
    max-width: 800px;
    max-height: 600px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    margin: 0 auto;
    position: relative; /* â˜…â˜…â˜… ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®åŸºæº–ä½ç½® â˜…â˜…â˜… */
  }

  .language-selector {
    padding: 12px 16px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    justify-content: flex-end;
    align-items: center;
  }

  .language-dropdown {
    padding: 6px 12px;
    border: 2px solid white;
    border-radius: 20px;
    background: rgba(255, 255, 255, 0.95);
    color: #667eea;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    outline: none;
    transition: all 0.2s;
  }

  .language-dropdown:hover {
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  }

  .language-dropdown:focus {
    border-color: #fbbf24;
  }

  .chat-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    text-align: center;
  }

  .chat-header h2 {
    font-size: 20px;
    font-weight: 600;
    margin: 0 0 4px 0;
  }

  .chat-header p {
    font-size: 13px;
    opacity: 0.9;
    margin: 0;
  }

  .voice-status {
    padding: 10px 15px;
    text-align: center;
    font-size: 12px;
    border-bottom: 1px solid #e0e0e0;
    font-weight: 500;
  }

  .voice-status.listening {
    background: #e8f5e9;
    color: #2e7d32;
    animation: pulse 2s infinite;
  }

  .voice-status.stopped {
    background: #ffebee;
    color: #c62828;
  }

  .voice-status.speaking {
    background: #e1f5fe;
    color: #0277bd;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }

  .chat-area {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    background: #f7f9fc;
    min-height: 300px;
  }

  .message {
    margin-bottom: 16px;
    display: flex;
    gap: 10px;
  }

  .message.assistant {
    flex-direction: row;
  }

  .message.user {
    flex-direction: row-reverse;
  }

  .message.system {
    justify-content: center;
  }

  .message-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    flex-shrink: 0;
  }

  .message.assistant .message-avatar {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
  }

  .message.user .message-avatar {
    background: #e0e7ff;
    color: #667eea;
  }

  .message.system .message-avatar {
    background: #fff3e0;
    color: #f57c00;
  }

  .message-content {
    max-width: 70%;
    padding: 10px 14px;
    border-radius: 12px;
    line-height: 1.5;
    font-size: 14px;
    white-space: pre-wrap;
  }

  .message.assistant .message-content {
    background: white;
    border: 1px solid #e5e7eb;
    color: #1f2937;
  }

  .message.user .message-content {
    background: #667eea;
    color: white;
  }

  .message.system .message-content {
    background: #fff3e0;
    color: #e65100;
    font-size: 12px;
  }

  .summary-box {
    margin-top: 10px;
    padding: 10px;
    background: #fef3c7;
    border-left: 4px solid #f59e0b;
    border-radius: 8px;
    font-size: 13px;
    color: #92400e;
  }

  .summary-box strong {
    display: block;
    margin-bottom: 6px;
    color: #78350f;
  }

  .final-summary {
    margin: 16px 0;
    padding: 16px;
    background: white;
    border: 2px solid #10b981;
    border-radius: 12px;
  }

  .final-summary h3 {
    color: #065f46;
    margin: 0 0 10px 0;
    font-size: 16px;
  }

  .final-summary-content {
    white-space: pre-wrap;
    line-height: 1.7;
    color: #1f2937;
    font-size: 13px;
  }

  .input-area {
    padding: 16px;
    background: white;
    border-top: 1px solid #e5e7eb;
  }

  .input-group {
    display: flex;
    gap: 10px;
    align-items: center;
    margin-bottom: 10px;
  }

  #userInput {
    flex: 1;
    padding: 10px 14px;
    border: 2px solid #e5e7eb;
    border-radius: 20px;
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s;
  }

  #userInput:focus {
    border-color: #667eea;
  }

  .btn {
    padding: 10px 16px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .btn-secondary {
    background: #f3f4f6;
    color: #374151;
    font-size: 12px;
    padding: 8px 12px;
  }

  .btn-secondary:hover:not(:disabled) {
    background: #e5e7eb;
    box-shadow: none;
    transform: none;
  }

  .btn-reservation {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: white;
    font-size: 13px;
    padding: 10px 16px;
    font-weight: 600;
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
  }

  .btn-reservation:hover:not(:disabled) {
    box-shadow: 0 6px 16px rgba(245, 158, 11, 0.4);
    transform: translateY(-1px);
  }

  .btn-reservation:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .btn-icon {
    padding: 10px;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .btn-mic {
    background: #10b981;
  }

  .btn-mic:hover:not(:disabled) {
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
  }

  .btn-mic.recording {
    background: #ef4444;
    animation: pulse-btn 1.5s infinite;
  }

  @keyframes pulse-btn {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  .btn-speaker {
    background: #f59e0b;
  }

  .btn-speaker:hover:not(:disabled) {
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
  }

  .btn-speaker.disabled {
    background: #9ca3af;
  }

  .input-actions {
    display: flex;
    justify-content: flex-end;
  }

  .loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid #e5e7eb;
    border-radius: 50%;
    border-top-color: #667eea;
    animation: spin 1s ease-in-out infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .error-message {
    background: #fee2e2;
    color: #b91c1c;
    padding: 10px;
    border-radius: 8px;
    margin: 10px 0;
    font-size: 13px;
    text-align: center;
  }

  /* â˜…â˜…â˜… ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆãƒãƒ£ãƒƒãƒˆç”»é¢å†…ã®ã¿ï¼‰ â˜…â˜…â˜… */
  .splash-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    border-radius: 16px;
    overflow: hidden;
    transition: opacity 0.8s ease-out;
    pointer-events: all;
  }

  .splash-overlay.fade-out {
    opacity: 0;
    pointer-events: none;
  }

  .splash-overlay.hidden {
    display: none;
  }

  .splash-video {
    width: 100%;
    height: 100%;
    object-fit: contain;
    position: absolute;
    top: 0;
    left: 0;
    transform: scale(0.5);
    /* â˜…â˜…â˜… 30%ç¸®å°ï¼ˆ70%ã‚µã‚¤ã‚ºï¼‰ â˜…â˜…â˜… */
    /* åŠé€æ˜ã®å‹•ç”» â†’ èƒŒæ™¯ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒé€ã‘ã¦è¦‹ãˆã‚‹ */
  }

  .splash-loading {
    position: absolute;
    bottom: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    z-index: 1;
  }

  .splash-loading .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(102, 126, 234, 0.3);
    border-top-color: #667eea;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  .splash-loading p {
    color: #667eea;
    font-size: 14px;
    font-weight: 600;
    margin: 0;
    text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
  }

  /* ã‚¯ãƒªãƒƒã‚¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ */
  .click-prompt {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 12px;
    text-align: center;
    z-index: 100;
    cursor: pointer;
  }

  .click-prompt p {
    margin: 5px 0;
  }

  /* â˜…â˜…â˜… è¿½åŠ : å¾…æ©Ÿã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ã‚¹ã‚¿ã‚¤ãƒ« â˜…â˜…â˜… */
  .wait-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.95);
    z-index: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 16px;
    opacity: 1;
    transition: opacity 0.5s ease-out, visibility 0.5s;
  }

  .wait-overlay.hidden {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
  }

  .wait-content {
    text-align: center;
    width: 80%;
    max-width: 400px;
  }

  .wait-video {
    width: 100%;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.1);
    margin-bottom: 16px;
  }

  .wait-text {
    color: #667eea;
    font-weight: 600;
    font-size: 14px;
    animation: pulse 1.5s infinite;
  }
</style>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<script>
  // å¤šè¨€èªå¯¾å¿œi18nã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  const i18n = {
    ja: {
      pageTitle: 'ã‚°ãƒ«ãƒ¡ã‚µãƒãƒ¼ãƒˆAI',
      pageSubtitle: 'AIãŒã‚ãªãŸã«ã´ã£ãŸã‚Šã®ãŠåº—ã‚’ã”ææ¡ˆã—ã¾ã™',
      shopListTitle: 'ãŠã™ã™ã‚ã®ãŠåº—',
      shopListEmpty: 'ãƒãƒ£ãƒƒãƒˆã§æ¤œç´¢ã™ã‚‹ã¨ã€ã“ã“ã«ãŠåº—ãŒè¡¨ç¤ºã•ã‚Œã¾ã™',
      footerMessage: 'ç´ æ•µãªã‚°ãƒ«ãƒ¡ä½“é¨“ã‚’ãŠæ¥½ã—ã¿ãã ã•ã„',
      initialGreeting: 'ã“ã‚“ã«ã¡ã¯!ã‚°ãƒ«ãƒ¡ã‚µãƒãƒ¼ãƒˆAIã§ã™ã€‚\n\næœ¬æ—¥ã¯ã©ã®ã‚ˆã†ãªãŠåº—ã‚’ãŠæ¢ã—ã—ã¾ã—ã‚‡ã†ã‹?',
      voiceStatusStopped: 'ğŸ¤ éŸ³å£°èªè­˜: åœæ­¢ä¸­',
      voiceStatusListening: 'ğŸ¤ è©±ã—ã¦ãã ã•ã„...',
      voiceStatusRecording: 'ğŸ¤ éŒ²éŸ³ä¸­...',
      voiceStatusWaiting: 'ğŸ¤ èªè­˜å¾…æ©Ÿä¸­...',
      voiceStatusRecognizing: 'ğŸ”Š éŸ³å£°èªè­˜ä¸­...',
      voiceStatusSynthesizing: 'ğŸ”Š éŸ³å£°åˆæˆä¸­...',
      voiceStatusSpeaking: 'ğŸ”Š éŸ³å£°å†ç”Ÿä¸­...',
      voiceStatusComplete: 'âœ… èªè­˜å®Œäº†',
      inputPlaceholder: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...',
      btnVoiceInput: 'éŸ³å£°å…¥åŠ›',
      btnTTSOn: 'éŸ³å£°èª­ã¿ä¸Šã’ON',
      btnTTSOff: 'éŸ³å£°èª­ã¿ä¸Šã’OFF',
      btnSend: 'é€ä¿¡',
      btnReservation: 'ğŸ“ äºˆç´„ä¾é ¼ã™ã‚‹',
      clickPrompt: 'éŸ³å£°ã‚’å†ç”Ÿã™ã‚‹ã«ã¯ã€ç”»é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„',
      recordingTimeLimit: 'éŒ²éŸ³æ™‚é–“ãŒä¸Šé™ï¼ˆ55ç§’ï¼‰ã«é”ã—ãŸãŸã‚è‡ªå‹•åœæ­¢ã—ã¾ã—ãŸ',
      micAccessError: 'ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼:',
      voiceNotRecognized: 'éŸ³å£°ãŒèªè­˜ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ',
      sttError: 'éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:',
      initError: 'åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚',
      searchError: 'ãŠåº—ã‚’æ¤œç´¢ã—ã¦ã‹ã‚‰ã”åˆ©ç”¨ãã ã•ã„ã€‚',
      loadingMessage: 'ææ¡ˆã™ã‚‹ãŠåº—ã®æƒ…å ±ã‚’æ¢ã—ã¦ã„ã¾ã™ã€‚å°‘ã€…ãŠå¾…ã¡ãã ã•ã„...',
      summaryTitle: 'ğŸ“‹ è³ªå•è¦ç´„æ›¸',
      summaryFooter: 'æ‹…å½“ã‚¹ã‚¿ãƒƒãƒ•ãŒå†…å®¹ã‚’ç¢ºèªã—ã€è¿½ã£ã¦ã”é€£çµ¡ã„ãŸã—ã¾ã™ã€‚',
      ackConfirm: 'ç¢ºèªã—ã¾ã™ã®ã§ã€å°‘ã€…ãŠå¾…ã¡ãã ã•ã„ã€‚',
      ackSearch: 'ãŠèª¿ã¹ã—ã¾ã™ã€‚',
      ackUnderstood: 'ã‹ã—ã“ã¾ã‚Šã¾ã—ãŸã€‚',
      ackYes: 'ã¯ã„ã€æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚',
      fallbackResponse: (text: string) => `"${text}"ã¨ã®ã“ã¨ã€‚ãŠèª¿ã¹ã—ã¾ã™ã®ã§ã€å°‘ã€…ãŠå¾…ã¡ãã ã•ã„ã€‚`,
      additionalResponse: 'åªä»Šã€ãŠåº—ã®æƒ…å ±ã‚’ç¢ºèªä¸­ã§ã™ã€‚ã‚‚ã†å°‘ã€…ãŠå¾…ã¡ãã ã•ã„ã€‚',
      ttsIntro: 'ãŠå¾…ãŸã›ã—ã¾ã—ãŸã€‚',
      // äºˆç´„ãƒ¢ãƒ¼ãƒ€ãƒ«
      reservationModalTitle: 'äºˆç´„ä¾é ¼',
      reservationShopSelect: 'ãŠåº—ã‚’é¸æŠ',
      reservationSelectionGuide: 'å„ªå…ˆé †ã«ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼ˆæœ€å¤§3ä»¶ï¼‰',
      reservationResetBtn: 'ã‚„ã‚Šç›´ã—',
      reservationPriorityNote: 'â‘ â†’â‘¡â†’â‘¢ã®é †ã§é›»è©±ã—ã¾ã™ã€‚äºˆç´„æˆç«‹æ™‚ç‚¹ã§çµ‚äº†ã—ã¾ã™ã€‚',
      reservationContentTitle: 'äºˆç´„å†…å®¹',
      reservationGuestCount: 'äººæ•°',
      reservationGuestOption: (n: number) => n === 10 ? '10åä»¥ä¸Š' : `${n}å`,
      reservationDate: 'å¸Œæœ›æ—¥',
      reservationTime: 'é–‹å§‹æ™‚é–“',
      reservationSelectPlaceholder: 'é¸æŠã—ã¦ãã ã•ã„',
      reservationTimeFlexibility: 'æ™‚é–“ã®è¨±å®¹ç¯„å›²',
      reservationTimeExact: 'é–‹å§‹æ™‚é–“å„ªå…ˆ',
      reservationTimePlus30: '+30åˆ†ã¾ã§',
      reservationTimePlus60: '+60åˆ†ã¾ã§',
      reservationTimePlus90: '+90åˆ†ã¾ã§',
      reservationSeatPreference: 'å¸­ã®å¸Œæœ›',
      reservationSeatTable: 'ãƒ†ãƒ¼ãƒ–ãƒ«å¸­',
      reservationSeatCounter: 'ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å¸­',
      reservationSeatPrivate: 'å€‹å®¤',
      reservationOtherRequests: 'ãã®ä»–ã®å¸Œæœ›',
      reservationOtherRequestsPlaceholder: 'èª•ç”Ÿæ—¥ã‚±ãƒ¼ã‚­ã€ã‚¢ãƒ¬ãƒ«ã‚®ãƒ¼å¯¾å¿œã€ç¦ç…™å¸­ãªã©',
      reservationPerShopBtn: 'ãŠåº—æ¯ã«äºˆç´„å†…å®¹ã‚’å¤‰ãˆã‚‹',
      reservationBackToCommon: 'å…±é€šè¨­å®šã«æˆ»ã™',
      reservationReserverInfo: 'äºˆç´„è€…æƒ…å ±',
      reservationReserverName: 'ãŠåå‰',
      reservationReserverNamePlaceholder: 'äºˆç´„è€…ã®ãŠåå‰',
      reservationReserverPhone: 'æºå¸¯ç•ªå·',
      reservationReserverPhoneHint: 'â€» åº—èˆ—ã¸ã®é€£çµ¡å…ˆã¨ã—ã¦ä¼ãˆã¾ã™',
      reservationCancel: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
      reservationSubmit: 'äºˆç´„ä¾é ¼ã‚’é–‹å§‹ã™ã‚‹',
      reservationSelectionRemaining: (n: number) => `ã‚ã¨${n}ä»¶é¸æŠã§ãã¾ã™`,
      reservationSelectionComplete: 'é¸æŠå®Œäº†ï¼ˆå¤‰æ›´ã™ã‚‹ã«ã¯åº—èˆ—ã‚’ã‚¯ãƒªãƒƒã‚¯ï¼‰',
      reservationSelectShopsFirst: 'å…ˆã«ãŠåº—ã‚’é¸æŠã—ã¦ãã ã•ã„',
      reservationPhoneLabel: 'é›»è©±ç•ªå·',
      reservationPhoneHint: 'â€» Places APIã‹ã‚‰å–å¾—ã€‚ä¿®æ­£å¯èƒ½',
      reservationPerShopPlaceholder: 'ã“ã®ãŠåº—ã¸ã®ç‰¹åˆ¥ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ',
      reservationAlertTitle: 'äºˆç´„ä¾é ¼ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚',
      reservationAlertReserver: 'äºˆç´„è€…',
      reservationAlertContact: 'é€£çµ¡å…ˆ',
      reservationAlertShops: 'é¸æŠã•ã‚ŒãŸãŠåº—',
      reservationAlertNoPhone: 'é›»è©±ç•ªå·ãªã—',
      reservationAlertDevNote: 'ï¼ˆã“ã®æ©Ÿèƒ½ã¯ç¾åœ¨é–‹ç™ºä¸­ã§ã™ï¼‰',
      reservationVoiceRecording: 'éŒ²éŸ³ä¸­...',
      reservationVoiceWaiting: 'èªè­˜å¾…æ©Ÿä¸­...',
      reservationVoiceSpeaking: 'è©±ã—ã¦ãã ã•ã„...',
      reservationVoiceError: 'ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼',
      reservationVoiceRecognizing: 'éŸ³å£°èªè­˜ä¸­...',
      reservationVoiceComplete: 'å…¥åŠ›å®Œäº†',
      reservationVoiceNotRecognized: 'éŸ³å£°ãŒèªè­˜ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ'
    },
    en: {
      pageTitle: 'Gourmet Support AI',
      pageSubtitle: 'AI will suggest the perfect restaurant for you',
      shopListTitle: 'Recommended Restaurants',
      shopListEmpty: 'Search in the chat to see restaurants here',
      footerMessage: 'Enjoy your wonderful dining experience',
      initialGreeting: 'Hello! I\'m the Gourmet Support AI.\n\nWhat kind of restaurant are you looking for today? I can help you find restaurants anywhere in the world.',
      voiceStatusStopped: 'ğŸ¤ Voice Recognition: Stopped',
      voiceStatusListening: 'ğŸ¤ Please speak...',
      voiceStatusRecording: 'ğŸ¤ Recording...',
      voiceStatusWaiting: 'ğŸ¤ Waiting for recognition...',
      voiceStatusRecognizing: 'ğŸ”Š Recognizing voice...',
      voiceStatusSynthesizing: 'ğŸ”Š Synthesizing voice...',
      voiceStatusSpeaking: 'ğŸ”Š Playing audio...',
      voiceStatusComplete: 'âœ… Recognition complete',
      inputPlaceholder: 'Enter message...',
      btnVoiceInput: 'Voice input',
      btnTTSOn: 'Voice reading ON',
      btnTTSOff: 'Voice reading OFF',
      btnSend: 'Send',
      btnReservation: 'ğŸ“ Request reservation',
      clickPrompt: 'Click the screen to play audio',
      recordingTimeLimit: 'Recording stopped automatically (55s limit reached)',
      micAccessError: 'Microphone access error:',
      voiceNotRecognized: 'Voice not recognized',
      sttError: 'Voice recognition error:',
      initError: 'Initialization failed. Please reload the page.',
      searchError: 'Please search for restaurants first.',
      loadingMessage: 'Searching for restaurant recommendations. Please wait...',
      summaryTitle: 'ğŸ“‹ Inquiry Summary',
      summaryFooter: 'Our staff will review your inquiry and contact you shortly.',
      ackConfirm: 'Let me check. Please wait a moment.',
      ackSearch: 'Let me look that up.',
      ackUnderstood: 'Understood.',
      ackYes: 'Yes, I understand.',
      fallbackResponse: (text: string) => `You said "${text}". Let me search for that. Please wait.`,
      additionalResponse: 'Currently searching for restaurant information. Please wait a moment.',
      ttsIntro: 'Thank you for waiting.',
      // Reservation Modal
      reservationModalTitle: 'Reservation Request',
      reservationShopSelect: 'Select Restaurants',
      reservationSelectionGuide: 'Click in priority order (up to 3)',
      reservationResetBtn: 'Reset',
      reservationPriorityNote: 'We will call in order â‘ â†’â‘¡â†’â‘¢. Process ends when reservation is confirmed.',
      reservationContentTitle: 'Reservation Details',
      reservationGuestCount: 'Party Size',
      reservationGuestOption: (n: number) => n === 10 ? '10+ people' : `${n} ${n === 1 ? 'person' : 'people'}`,
      reservationDate: 'Preferred Date',
      reservationTime: 'Start Time',
      reservationSelectPlaceholder: 'Please select',
      reservationTimeFlexibility: 'Time Flexibility',
      reservationTimeExact: 'Exact time preferred',
      reservationTimePlus30: 'Up to +30 min',
      reservationTimePlus60: 'Up to +60 min',
      reservationTimePlus90: 'Up to +90 min',
      reservationSeatPreference: 'Seating Preference',
      reservationSeatTable: 'Table',
      reservationSeatCounter: 'Counter',
      reservationSeatPrivate: 'Private room',
      reservationOtherRequests: 'Special Requests',
      reservationOtherRequestsPlaceholder: 'Birthday cake, allergy accommodations, non-smoking, etc.',
      reservationPerShopBtn: 'Set different details per restaurant',
      reservationBackToCommon: 'Back to common settings',
      reservationReserverInfo: 'Your Information',
      reservationReserverName: 'Name',
      reservationReserverNamePlaceholder: 'Your name',
      reservationReserverPhone: 'Phone Number',
      reservationReserverPhoneHint: 'â€» Will be provided to the restaurant',
      reservationCancel: 'Cancel',
      reservationSubmit: 'Submit Reservation Request',
      reservationSelectionRemaining: (n: number) => `${n} more can be selected`,
      reservationSelectionComplete: 'Selection complete (click to change)',
      reservationSelectShopsFirst: 'Please select restaurants first',
      reservationPhoneLabel: 'Phone Number',
      reservationPhoneHint: 'â€» Retrieved from Places API. Editable',
      reservationPerShopPlaceholder: 'Special requests for this restaurant',
      reservationAlertTitle: 'Reservation request received.',
      reservationAlertReserver: 'Name',
      reservationAlertContact: 'Contact',
      reservationAlertShops: 'Selected Restaurants',
      reservationAlertNoPhone: 'No phone',
      reservationAlertDevNote: '(This feature is currently under development)',
      reservationVoiceRecording: 'Recording...',
      reservationVoiceWaiting: 'Waiting for recognition...',
      reservationVoiceSpeaking: 'Please speak...',
      reservationVoiceError: 'Microphone access error',
      reservationVoiceRecognizing: 'Recognizing voice...',
      reservationVoiceComplete: 'Input complete',
      reservationVoiceNotRecognized: 'Voice not recognized'
    },
    zh: {
      pageTitle: 'ç¾é£Ÿæ”¯æŒAI',
      pageSubtitle: 'AIä¸ºæ‚¨æ¨èå®Œç¾çš„é¤å…',
      shopListTitle: 'æ¨èé¤å…',
      shopListEmpty: 'åœ¨èŠå¤©ä¸­æœç´¢åï¼Œé¤å…å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ',
      footerMessage: 'ç¥æ‚¨äº«å—ç¾å¥½çš„ç¾é£Ÿä½“éªŒ',
      initialGreeting: 'æ‚¨å¥½ï¼æˆ‘æ˜¯ç¾é£Ÿæ”¯æŒAIã€‚\n\nä»Šå¤©æ‚¨æƒ³æ‰¾ä»€ä¹ˆæ ·çš„é¤å…å‘¢ï¼Ÿæˆ‘å¯ä»¥å¸®æ‚¨æœç´¢å…¨çƒå„åœ°çš„é¤å…ã€‚',
      voiceStatusStopped: 'ğŸ¤ è¯­éŸ³è¯†åˆ«: å·²åœæ­¢',
      voiceStatusListening: 'ğŸ¤ è¯·è¯´è¯...',
      voiceStatusRecording: 'ğŸ¤ å½•éŸ³ä¸­...',
      voiceStatusWaiting: 'ğŸ¤ ç­‰å¾…è¯†åˆ«...',
      voiceStatusRecognizing: 'ğŸ”Š è¯†åˆ«è¯­éŸ³ä¸­...',
      voiceStatusSynthesizing: 'ğŸ”Š è¯­éŸ³åˆæˆä¸­...',
      voiceStatusSpeaking: 'ğŸ”Š æ’­æ”¾éŸ³é¢‘ä¸­...',
      voiceStatusComplete: 'âœ… è¯†åˆ«å®Œæˆ',
      inputPlaceholder: 'è¾“å…¥æ¶ˆæ¯...',
      btnVoiceInput: 'è¯­éŸ³è¾“å…¥',
      btnTTSOn: 'è¯­éŸ³æœ—è¯»å¼€å¯',
      btnTTSOff: 'è¯­éŸ³æœ—è¯»å…³é—­',
      btnSend: 'å‘é€',
      btnReservation: 'ğŸ“ ç”³è¯·é¢„çº¦',
      clickPrompt: 'ç‚¹å‡»å±å¹•æ’­æ”¾éŸ³é¢‘',
      recordingTimeLimit: 'å½•éŸ³å·²è‡ªåŠ¨åœæ­¢ï¼ˆè¾¾åˆ°55ç§’ä¸Šé™ï¼‰',
      micAccessError: 'éº¦å…‹é£è®¿é—®é”™è¯¯:',
      voiceNotRecognized: 'æœªè¯†åˆ«åˆ°è¯­éŸ³',
      sttError: 'è¯­éŸ³è¯†åˆ«é”™è¯¯:',
      initError: 'åˆå§‹åŒ–å¤±è´¥ã€‚è¯·é‡æ–°åŠ è½½é¡µé¢ã€‚',
      searchError: 'è¯·å…ˆæœç´¢é¤å…ã€‚',
      loadingMessage: 'æ­£åœ¨æœç´¢æ¨èé¤å…ã€‚è¯·ç¨å€™...',
      summaryTitle: 'ğŸ“‹ å’¨è¯¢æ‘˜è¦',
      summaryFooter: 'æˆ‘ä»¬çš„å·¥ä½œäººå‘˜å°†å®¡æ ¸æ‚¨çš„å’¨è¯¢å¹¶å°½å¿«è”ç³»æ‚¨ã€‚',
      ackConfirm: 'æˆ‘ç¡®è®¤ä¸€ä¸‹ã€‚è¯·ç¨ç­‰ã€‚',
      ackSearch: 'æˆ‘æŸ¥ä¸€ä¸‹ã€‚',
      ackUnderstood: 'æ˜ç™½äº†ã€‚',
      ackYes: 'å¥½çš„ï¼Œæˆ‘çŸ¥é“äº†ã€‚',
      fallbackResponse: (text: string) => `æ‚¨è¯´"${text}"ã€‚æˆ‘æœç´¢ä¸€ä¸‹ã€‚è¯·ç¨ç­‰ã€‚`,
      additionalResponse: 'æ­£åœ¨ç¡®è®¤é¤å…ä¿¡æ¯ã€‚è¯·ç¨å€™ã€‚',
      ttsIntro: 'è®©æ‚¨ä¹…ç­‰äº†ã€‚',
      // é¢„çº¦æ¨¡æ€æ¡†
      reservationModalTitle: 'é¢„çº¦ç”³è¯·',
      reservationShopSelect: 'é€‰æ‹©é¤å…',
      reservationSelectionGuide: 'æŒ‰ä¼˜å…ˆé¡ºåºç‚¹å‡»ï¼ˆæœ€å¤š3å®¶ï¼‰',
      reservationResetBtn: 'é‡ç½®',
      reservationPriorityNote: 'å°†æŒ‰â‘ â†’â‘¡â†’â‘¢çš„é¡ºåºè‡´ç”µã€‚é¢„çº¦æˆåŠŸåç»“æŸã€‚',
      reservationContentTitle: 'é¢„çº¦è¯¦æƒ…',
      reservationGuestCount: 'äººæ•°',
      reservationGuestOption: (n: number) => n === 10 ? '10äººä»¥ä¸Š' : `${n}äºº`,
      reservationDate: 'å¸Œæœ›æ—¥æœŸ',
      reservationTime: 'å¼€å§‹æ—¶é—´',
      reservationSelectPlaceholder: 'è¯·é€‰æ‹©',
      reservationTimeFlexibility: 'æ—¶é—´å¼¹æ€§',
      reservationTimeExact: 'ä¼˜å…ˆå¼€å§‹æ—¶é—´',
      reservationTimePlus30: 'æœ€å¤š+30åˆ†é’Ÿ',
      reservationTimePlus60: 'æœ€å¤š+60åˆ†é’Ÿ',
      reservationTimePlus90: 'æœ€å¤š+90åˆ†é’Ÿ',
      reservationSeatPreference: 'åº§ä½åå¥½',
      reservationSeatTable: 'æ¡Œå¸­',
      reservationSeatCounter: 'å§å°å¸­',
      reservationSeatPrivate: 'åŒ…é—´',
      reservationOtherRequests: 'å…¶ä»–è¦æ±‚',
      reservationOtherRequestsPlaceholder: 'ç”Ÿæ—¥è›‹ç³•ã€è¿‡æ•å¯¹åº”ã€ç¦çƒŸåº§ä½ç­‰',
      reservationPerShopBtn: 'ä¸ºæ¯å®¶é¤å…è®¾ç½®ä¸åŒè¯¦æƒ…',
      reservationBackToCommon: 'è¿”å›é€šç”¨è®¾ç½®',
      reservationReserverInfo: 'é¢„çº¦äººä¿¡æ¯',
      reservationReserverName: 'å§“å',
      reservationReserverNamePlaceholder: 'é¢„çº¦äººå§“å',
      reservationReserverPhone: 'æ‰‹æœºå·ç ',
      reservationReserverPhoneHint: 'â€» å°†å‘ŠçŸ¥é¤å…ä½œä¸ºè”ç³»æ–¹å¼',
      reservationCancel: 'å–æ¶ˆ',
      reservationSubmit: 'æäº¤é¢„çº¦ç”³è¯·',
      reservationSelectionRemaining: (n: number) => `è¿˜å¯é€‰æ‹©${n}å®¶`,
      reservationSelectionComplete: 'é€‰æ‹©å®Œæˆï¼ˆç‚¹å‡»å¯æ›´æ”¹ï¼‰',
      reservationSelectShopsFirst: 'è¯·å…ˆé€‰æ‹©é¤å…',
      reservationPhoneLabel: 'ç”µè¯å·ç ',
      reservationPhoneHint: 'â€» ä»Places APIè·å–ã€‚å¯ç¼–è¾‘',
      reservationPerShopPlaceholder: 'å¯¹æ­¤é¤å…çš„ç‰¹æ®Šè¦æ±‚',
      reservationAlertTitle: 'å·²æ¥å—é¢„çº¦ç”³è¯·ã€‚',
      reservationAlertReserver: 'é¢„çº¦äºº',
      reservationAlertContact: 'è”ç³»æ–¹å¼',
      reservationAlertShops: 'é€‰æ‹©çš„é¤å…',
      reservationAlertNoPhone: 'æ— ç”µè¯',
      reservationAlertDevNote: 'ï¼ˆæ­¤åŠŸèƒ½ç›®å‰æ­£åœ¨å¼€å‘ä¸­ï¼‰',
      reservationVoiceRecording: 'å½•éŸ³ä¸­...',
      reservationVoiceWaiting: 'ç­‰å¾…è¯†åˆ«...',
      reservationVoiceSpeaking: 'è¯·è¯´è¯...',
      reservationVoiceError: 'éº¦å…‹é£è®¿é—®é”™è¯¯',
      reservationVoiceRecognizing: 'è¯†åˆ«è¯­éŸ³ä¸­...',
      reservationVoiceComplete: 'è¾“å…¥å®Œæˆ',
      reservationVoiceNotRecognized: 'æœªè¯†åˆ«åˆ°è¯­éŸ³'
    },
    ko: {
      pageTitle: 'ë¯¸ì‹ ì§€ì› AI',
      pageSubtitle: 'AIê°€ ì™„ë²½í•œ ë ˆìŠ¤í† ë‘ì„ ì¶”ì²œí•´ ë“œë¦½ë‹ˆë‹¤',
      shopListTitle: 'ì¶”ì²œ ë ˆìŠ¤í† ë‘',
      shopListEmpty: 'ì±„íŒ…ì—ì„œ ê²€ìƒ‰í•˜ë©´ ì—¬ê¸°ì— ë ˆìŠ¤í† ë‘ì´ í‘œì‹œë©ë‹ˆë‹¤',
      footerMessage: 'ë©‹ì§„ ë¯¸ì‹ ê²½í—˜ì„ ì¦ê¸°ì„¸ìš”',
      initialGreeting: 'ì•ˆë…•í•˜ì„¸ìš”! ë¯¸ì‹ ì§€ì› AIì…ë‹ˆë‹¤.\n\nì˜¤ëŠ˜ì€ ì–´ë–¤ ìŒì‹ì ì„ ì°¾ìœ¼ì‹œë‚˜ìš”? ì „ ì„¸ê³„ ì–´ë””ë“  ìŒì‹ì ì„ ê²€ìƒ‰í•´ ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
      voiceStatusStopped: 'ğŸ¤ ìŒì„± ì¸ì‹: ì •ì§€ë¨',
      voiceStatusListening: 'ğŸ¤ ë§ì”€í•´ ì£¼ì„¸ìš”...',
      voiceStatusRecording: 'ğŸ¤ ë…¹ìŒ ì¤‘...',
      voiceStatusWaiting: 'ğŸ¤ ì¸ì‹ ëŒ€ê¸° ì¤‘...',
      voiceStatusRecognizing: 'ğŸ”Š ìŒì„± ì¸ì‹ ì¤‘...',
      voiceStatusSynthesizing: 'ğŸ”Š ìŒì„± í•©ì„± ì¤‘...',
      voiceStatusSpeaking: 'ğŸ”Š ì˜¤ë””ì˜¤ ì¬ìƒ ì¤‘...',
      voiceStatusComplete: 'âœ… ì¸ì‹ ì™„ë£Œ',
      inputPlaceholder: 'ë©”ì‹œì§€ ì…ë ¥...',
      btnVoiceInput: 'ìŒì„± ì…ë ¥',
      btnTTSOn: 'ìŒì„± ì½ê¸° ì¼œì§',
      btnTTSOff: 'ìŒì„± ì½ê¸° êº¼ì§',
      btnSend: 'ì „ì†¡',
      btnReservation: 'ğŸ“ ì˜ˆì•½ ì‹ ì²­',
      clickPrompt: 'ì˜¤ë””ì˜¤ë¥¼ ì¬ìƒí•˜ë ¤ë©´ í™”ë©´ì„ í´ë¦­í•˜ì„¸ìš”',
      recordingTimeLimit: 'ë…¹ìŒì´ ìë™ìœ¼ë¡œ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤ (55ì´ˆ ì œí•œ ë„ë‹¬)',
      micAccessError: 'ë§ˆì´í¬ ì•¡ì„¸ìŠ¤ ì˜¤ë¥˜:',
      voiceNotRecognized: 'ìŒì„±ì´ ì¸ì‹ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
      sttError: 'ìŒì„± ì¸ì‹ ì˜¤ë¥˜:',
      initError: 'ì´ˆê¸°í™” ì‹¤íŒ¨. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.',
      searchError: 'ë¨¼ì € ë ˆìŠ¤í† ë‘ì„ ê²€ìƒ‰í•˜ì„¸ìš”.',
      loadingMessage: 'ì¶”ì²œ ë ˆìŠ¤í† ë‘ì„ ê²€ìƒ‰ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...',
      summaryTitle: 'ğŸ“‹ ë¬¸ì˜ ìš”ì•½',
      summaryFooter: 'ë‹´ë‹¹ìê°€ ë¬¸ì˜ ë‚´ìš©ì„ ê²€í† í•˜ê³  ê³§ ì—°ë½ë“œë¦¬ê² ìŠµë‹ˆë‹¤.',
      ackConfirm: 'í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.',
      ackSearch: 'ì°¾ì•„ë³´ê² ìŠµë‹ˆë‹¤.',
      ackUnderstood: 'ì•Œê² ìŠµë‹ˆë‹¤.',
      ackYes: 'ë„¤, ì•Œê² ìŠµë‹ˆë‹¤.',
      fallbackResponse: (text: string) => `"${text}"ë¼ê³  ë§ì”€í•˜ì…¨ë„¤ìš”. ê²€ìƒ‰í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.`,
      additionalResponse: 'ì§€ê¸ˆ ë ˆìŠ¤í† ë‘ ì •ë³´ë¥¼ í™•ì¸ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.',
      ttsIntro: 'ê¸°ë‹¤ë ¤ ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.',
      // ì˜ˆì•½ ëª¨ë‹¬
      reservationModalTitle: 'ì˜ˆì•½ ì‹ ì²­',
      reservationShopSelect: 'ë ˆìŠ¤í† ë‘ ì„ íƒ',
      reservationSelectionGuide: 'ìš°ì„ ìˆœìœ„ëŒ€ë¡œ í´ë¦­í•˜ì„¸ìš” (ìµœëŒ€ 3ê³³)',
      reservationResetBtn: 'ë‹¤ì‹œ í•˜ê¸°',
      reservationPriorityNote: 'â‘ â†’â‘¡â†’â‘¢ ìˆœì„œë¡œ ì „í™”í•©ë‹ˆë‹¤. ì˜ˆì•½ ì„±ë¦½ ì‹œ ì¢…ë£Œí•©ë‹ˆë‹¤.',
      reservationContentTitle: 'ì˜ˆì•½ ë‚´ìš©',
      reservationGuestCount: 'ì¸ì›',
      reservationGuestOption: (n: number) => n === 10 ? '10ëª… ì´ìƒ' : `${n}ëª…`,
      reservationDate: 'í¬ë§ ë‚ ì§œ',
      reservationTime: 'ì‹œì‘ ì‹œê°„',
      reservationSelectPlaceholder: 'ì„ íƒí•˜ì„¸ìš”',
      reservationTimeFlexibility: 'ì‹œê°„ í—ˆìš© ë²”ìœ„',
      reservationTimeExact: 'ì‹œì‘ ì‹œê°„ ìš°ì„ ',
      reservationTimePlus30: '+30ë¶„ê¹Œì§€',
      reservationTimePlus60: '+60ë¶„ê¹Œì§€',
      reservationTimePlus90: '+90ë¶„ê¹Œì§€',
      reservationSeatPreference: 'ì¢Œì„ í¬ë§',
      reservationSeatTable: 'í…Œì´ë¸”ì„',
      reservationSeatCounter: 'ì¹´ìš´í„°ì„',
      reservationSeatPrivate: 'ë£¸',
      reservationOtherRequests: 'ê¸°íƒ€ ìš”ì²­',
      reservationOtherRequestsPlaceholder: 'ìƒì¼ ì¼€ì´í¬, ì•Œë ˆë¥´ê¸° ëŒ€ì‘, ê¸ˆì—°ì„ ë“±',
      reservationPerShopBtn: 'ë ˆìŠ¤í† ë‘ë³„ë¡œ ì˜ˆì•½ ë‚´ìš© ë‹¤ë¥´ê²Œ ì„¤ì •',
      reservationBackToCommon: 'ê³µí†µ ì„¤ì •ìœ¼ë¡œ ëŒì•„ê°€ê¸°',
      reservationReserverInfo: 'ì˜ˆì•½ì ì •ë³´',
      reservationReserverName: 'ì„±í•¨',
      reservationReserverNamePlaceholder: 'ì˜ˆì•½ì ì„±í•¨',
      reservationReserverPhone: 'ì „í™”ë²ˆí˜¸',
      reservationReserverPhoneHint: 'â€» ë ˆìŠ¤í† ë‘ì— ì—°ë½ì²˜ë¡œ ì „ë‹¬ë©ë‹ˆë‹¤',
      reservationCancel: 'ì·¨ì†Œ',
      reservationSubmit: 'ì˜ˆì•½ ì‹ ì²­ ì‹œì‘',
      reservationSelectionRemaining: (n: number) => `${n}ê³³ ë” ì„ íƒ ê°€ëŠ¥`,
      reservationSelectionComplete: 'ì„ íƒ ì™„ë£Œ (ë³€ê²½í•˜ë ¤ë©´ í´ë¦­)',
      reservationSelectShopsFirst: 'ë¨¼ì € ë ˆìŠ¤í† ë‘ì„ ì„ íƒí•˜ì„¸ìš”',
      reservationPhoneLabel: 'ì „í™”ë²ˆí˜¸',
      reservationPhoneHint: 'â€» Places APIì—ì„œ ê°€ì ¸ì˜´. ìˆ˜ì • ê°€ëŠ¥',
      reservationPerShopPlaceholder: 'ì´ ë ˆìŠ¤í† ë‘ì— ëŒ€í•œ íŠ¹ë³„ ìš”ì²­',
      reservationAlertTitle: 'ì˜ˆì•½ ì‹ ì²­ì„ ì ‘ìˆ˜í–ˆìŠµë‹ˆë‹¤.',
      reservationAlertReserver: 'ì˜ˆì•½ì',
      reservationAlertContact: 'ì—°ë½ì²˜',
      reservationAlertShops: 'ì„ íƒí•œ ë ˆìŠ¤í† ë‘',
      reservationAlertNoPhone: 'ì „í™”ë²ˆí˜¸ ì—†ìŒ',
      reservationAlertDevNote: '(ì´ ê¸°ëŠ¥ì€ í˜„ì¬ ê°œë°œ ì¤‘ì…ë‹ˆë‹¤)',
      reservationVoiceRecording: 'ë…¹ìŒ ì¤‘...',
      reservationVoiceWaiting: 'ì¸ì‹ ëŒ€ê¸° ì¤‘...',
      reservationVoiceSpeaking: 'ë§ì”€í•´ ì£¼ì„¸ìš”...',
      reservationVoiceError: 'ë§ˆì´í¬ ì•¡ì„¸ìŠ¤ ì˜¤ë¥˜',
      reservationVoiceRecognizing: 'ìŒì„± ì¸ì‹ ì¤‘...',
      reservationVoiceComplete: 'ì…ë ¥ ì™„ë£Œ',
      reservationVoiceNotRecognized: 'ìŒì„±ì´ ì¸ì‹ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'
    }
  };

  // TTS/STTè¨€èªã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°
  const LANGUAGE_CODE_MAP = {
    ja: { tts: 'ja-JP', stt: 'ja-JP', voice: 'ja-JP-Chirp3-HD-Leda' },
    en: { tts: 'en-US', stt: 'en-US', voice: 'en-US-Studio-O' },
    zh: { tts: 'cmn-CN', stt: 'cmn-CN', voice: 'cmn-CN-Wavenet-A' },
    ko: { tts: 'ko-KR', stt: 'ko-KR', voice: 'ko-KR-Wavenet-A' }
  };

  // ã‚°ãƒ«ãƒ¡ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.gourmet-chat-container') as HTMLElement;
    if (!container) return;

    const apiBase = container.dataset.apiBase || '';

    // â˜…â˜…â˜… ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆ¶å¾¡ â˜…â˜…â˜…
    const splashOverlay = document.getElementById('splashOverlay') as HTMLDivElement;
    const splashVideo = document.getElementById('splashVideo') as HTMLVideoElement;

    function hideSplash() {
      console.log('[Splash] ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥çµ‚äº†');
      splashVideo.loop = false; // ãƒ«ãƒ¼ãƒ—åœæ­¢
      splashOverlay.classList.add('fade-out');
      setTimeout(() => splashOverlay.classList.add('hidden'), 800);
    }

    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: 10ç§’ã§å¼·åˆ¶çµ‚äº†
    setTimeout(() => {
      console.log('[Splash] ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ - å¼·åˆ¶çµ‚äº†');
      hideSplash();
    }, 10000);

    // â˜…â˜…â˜… ã“ã“ã¾ã§ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆ¶å¾¡ â˜…â˜…â˜…

    // DOMè¦ç´ 
    const chatArea = document.getElementById('chatArea')!;
    const userInput = document.getElementById('userInput') as HTMLInputElement;
    const sendBtn = document.getElementById('sendBtn') as HTMLButtonElement;
    const micBtn = document.getElementById('micBtn') as HTMLButtonElement;
    const speakerBtn = document.getElementById('speakerBtn') as HTMLButtonElement;
    const reservationBtn = document.getElementById('reservationBtn') as HTMLButtonElement;
    const voiceStatus = document.getElementById('voiceStatus')!;
    const languageSelect = document.getElementById('languageSelect') as HTMLSelectElement;

    // â˜…â˜…â˜… è¿½åŠ : å¾…æ©Ÿå‹•ç”»ç”¨DOMè¦ç´  â˜…â˜…â˜…
    const waitOverlay = document.getElementById('waitOverlay') as HTMLDivElement;
    const waitVideo = document.getElementById('waitVideo') as HTMLVideoElement;
    let waitOverlayTimer: number | null = null; // ã‚¿ã‚¤ãƒãƒ¼ç”¨å¤‰æ•°

    // â˜…â˜…â˜… è¿½åŠ : å¾…æ©Ÿå‹•ç”»ã®åˆ¶å¾¡é–¢æ•° â˜…â˜…â˜…
    function showWaitOverlay() {
      waitOverlay.classList.remove('hidden');
      waitVideo.currentTime = 0;
      waitVideo.play().catch(e => console.log('Video play error:', e));
    }

    function hideWaitOverlay() {
      // ã‚¿ã‚¤ãƒãƒ¼ãŒæ®‹ã£ã¦ã„ãŸã‚‰ã‚¯ãƒªã‚¢
      if (waitOverlayTimer) {
        clearTimeout(waitOverlayTimer);
        waitOverlayTimer = null;
      }
      waitOverlay.classList.add('hidden');
      setTimeout(() => {
        waitVideo.pause();
      }, 500);
    }

    // çŠ¶æ…‹
    let currentLanguage: 'ja' | 'en' | 'zh' | 'ko' = 'ja'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨€èª
    let sessionId: string | null = null;
    let isProcessing = false;
    let currentStage = 'conversation';
    let isRecording = false;
    let mediaRecorder: MediaRecorder | null = null;
    let audioChunks: Blob[] = [];
    let recordingTimer: number | null = null;
    const MAX_RECORDING_TIME = 55000; // 55ç§’ï¼ˆAPIã®60ç§’åˆ¶é™ã‚ˆã‚ŠçŸ­ãè¨­å®šï¼‰
    let isTTSEnabled = true;
    let currentAudio: HTMLAudioElement | null = null;
    let isUserInteracted = false;
    let currentShops: any[] = []; // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚·ãƒ§ãƒƒãƒ—ãƒªã‚¹ãƒˆ
    let isFromVoiceInput = false; // éŸ³å£°å…¥åŠ›ã‹ã‚‰ã®é€ä¿¡ã‹ã©ã†ã‹ã‚’è¿½è·¡

    // ç¿»è¨³ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    function t(key: string, ...args: any[]): string {
      const translation = i18n[currentLanguage][key];
      if (typeof translation === 'function') {
        return translation(...args);
      }
      return translation || key;
    }

    // i18nã¨translationé–¢æ•°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å…¬é–‹ï¼ˆReservationModalç”¨ï¼‰
    (window as any).gourmetI18n = {
      i18n: i18n,
      getCurrentLanguage: () => currentLanguage,
      t: (key: string, ...args: any[]) => t(key, ...args)
    };

    // UIè¨€èªã‚’æ›´æ–°
    function updateUILanguage() {
      // ãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã®è¦ç´ 
      voiceStatus.innerHTML = t('voiceStatusStopped');
      userInput.placeholder = t('inputPlaceholder');
      micBtn.title = t('btnVoiceInput');
      speakerBtn.title = isTTSEnabled ? t('btnTTSOn') : t('btnTTSOff');
      sendBtn.textContent = t('btnSend');
      reservationBtn.innerHTML = t('btnReservation');

      // ãƒšãƒ¼ã‚¸å…¨ä½“ã®è¦ç´ ï¼ˆindex.astroå†…ï¼‰
      const pageTitle = document.getElementById('pageTitle');
      const pageSubtitle = document.getElementById('pageSubtitle');
      const shopListTitle = document.getElementById('shopListTitle');
      const shopListEmpty = document.getElementById('shopListEmpty');
      const pageFooter = document.getElementById('pageFooter');

      // [å¤‰æ›´å‰] çµµæ–‡å­—ã€ŒğŸ½ã€ã§ä¸Šæ›¸ãã•ã‚Œã¦ã„ãŸ
      // if (pageTitle) pageTitle.innerHTML = `ğŸ½ ${t('pageTitle')}`;
      // [å¤‰æ›´å¾Œ] ç”»åƒã‚¿ã‚°ã‚’ä½¿ã£ã¦æ›´æ–°ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£
      if (pageTitle) {
        pageTitle.innerHTML = `<img src="/pwa-152x152.png" alt="Logo" class="app-logo" /> ${t('pageTitle')}`;
      }

      if (pageSubtitle) pageSubtitle.textContent = t('pageSubtitle');
      if (shopListTitle) shopListTitle.innerHTML = `ğŸ½ ${t('shopListTitle')}`;
      if (shopListEmpty) shopListEmpty.textContent = t('shopListEmpty');
      if (pageFooter) pageFooter.innerHTML = `${t('footerMessage')} âœ¨`;

      // ãƒãƒ£ãƒƒãƒˆã®æœ€åˆã®æŒ¨æ‹¶ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›´æ–°
      const initialMessage = chatArea.querySelector('.message.assistant[data-initial="true"]');
      if (initialMessage) {
        const messageText = initialMessage.querySelector('.message-text');
        if (messageText) {
          messageText.textContent = t('initialGreeting');
        }
      }

      // ReservationModalã«è¨€èªå¤‰æ›´ã‚’é€šçŸ¥
      const languageChangeEvent = new CustomEvent('languageChange', {
        detail: { language: currentLanguage }
      });
      document.dispatchEvent(languageChangeEvent);
    }

    // è¨€èªé¸æŠã‚¤ãƒ™ãƒ³ãƒˆ
    languageSelect.addEventListener('change', () => {
      currentLanguage = languageSelect.value as 'ja' | 'en' | 'zh' | 'ko';
      updateUILanguage();
      console.log(`[Language] è¨€èªåˆ‡æ›¿: ${currentLanguage}`);
    });

    // äº‹å‰ç”ŸæˆéŸ³å£°ï¼ˆæ¡ˆ1: é«˜é€Ÿå¿œç­”ç”¨ï¼‰
    let preGeneratedAcks: Map<string, string> = new Map(); // key: ãƒ†ã‚­ã‚¹ãƒˆ, value: base64 MP3

    // ç„¡éŸ³æ¤œå‡ºç”¨
    let audioContext: AudioContext | null = null;
    let analyser: AnalyserNode | null = null;
    let silenceTimer: number | null = null;
    let vadCheckInterval: number | null = null;
    let hasSpoken = false; // éŸ³å£°ãŒæ¤œå‡ºã•ã‚ŒãŸã‹ã©ã†ã‹
    let recordingStartTime = 0; // éŒ²éŸ³é–‹å§‹æ™‚åˆ»
    const SILENCE_THRESHOLD = 35; // ç„¡éŸ³åˆ¤å®šã®é–¾å€¤ï¼ˆ0-255ï¼‰â€»ç’°å¢ƒãƒã‚¤ã‚ºã‚’ç„¡è¦–
    const SILENCE_DURATION = 2000; // ç„¡éŸ³ãŒç¶šã„ãŸã‚‰åœæ­¢ã™ã‚‹ãƒŸãƒªç§’ï¼ˆ2ç§’ï¼‰
    const MIN_RECORDING_TIME = 3000; // æœ€å°éŒ²éŸ³æ™‚é–“ï¼ˆ3ç§’ï¼‰- ãƒã‚¤ã‚¯åˆæœŸåŒ–éŸ³ã‚’ç„¡è¦–

    // WebSocket Streaming STTç”¨ï¼ˆæ¡ˆ2: å®Œå…¨å®Ÿè£…ï¼‰
    let socket: any = null;
    let audioWorkletNode: AudioWorkletNode | null = null;
    let streamingTranscript = ''; // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ èªè­˜çµæœ
    let isStreamingSTT = false; // Streaming STTä½¿ç”¨ãƒ•ãƒ©ã‚°

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡º
    function enableAudioPlayback() {
      if (!isUserInteracted) {
        isUserInteracted = true;
        const clickPrompt = container.querySelector('.click-prompt');
        if (clickPrompt) clickPrompt.remove();
      }
    }

    // ã‚¯ãƒªãƒƒã‚¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤º
    function showClickPrompt() {
      const prompt = document.createElement('div');
      prompt.className = 'click-prompt';
      prompt.innerHTML = `
        <p>ğŸ”Š</p>
        <p>${t('clickPrompt')}</p>
        <p>ğŸ”Š</p>
      `;
      prompt.addEventListener('click', enableAudioPlayback);
      container.style.position = 'relative';
      container.appendChild(prompt);
    }

    // éŸ³å£°åœæ­¢
    function stopCurrentAudio() {
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.src = '';
        currentAudio = null;
      }
    }

    // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜å·ã‚’é™¤å»ï¼ˆTTSç”¨ï¼‰
    function stripMarkdown(text: string): string {
      return text
        // **å¤ªå­—** ã‚„ *æ–œä½“* ã‚’é™¤å»
        .replace(/\*\*([^*]+)\*\*/g, '$1')
        .replace(/\*([^*]+)\*/g, '$1')
        // __å¤ªå­—__ ã‚„ _æ–œä½“_ ã‚’é™¤å»
        .replace(/__([^_]+)__/g, '$1')
        .replace(/_([^_]+)_/g, '$1')
        // # è¦‹å‡ºã— ã‚’é™¤å»
        .replace(/^#+\s*/gm, '')
        // [ãƒªãƒ³ã‚¯ãƒ†ã‚­ã‚¹ãƒˆ](URL) ã‚’ ãƒªãƒ³ã‚¯ãƒ†ã‚­ã‚¹ãƒˆ ã«
        .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
        // `ã‚³ãƒ¼ãƒ‰` ã‚’é™¤å»
        .replace(/`([^`]+)`/g, '$1')
        // ç•ªå·ãƒªã‚¹ãƒˆã®ç•ªå·ã‚’èª­ã¿ã‚„ã™ã
        .replace(/^(\d+)\.\s+/gm, '$1ç•ªç›®ã€')
        // ä½™åˆ†ãªç©ºç™½ã‚’æ•´ç†
        .replace(/\s+/g, ' ')
        .trim();
    }

    // GCP TTSéŸ³å£°åˆæˆ
    async function speakTextGCP(text: string, stopPrevious: boolean = true) {
      console.log('[TTS] speakTextGCP å‘¼ã³å‡ºã—:', text.substring(0, 50) + '...', 'æ–‡å­—æ•°:', text.length);
      if (!isTTSEnabled || !text) return;

      if (stopPrevious) {
        stopCurrentAudio();
      }

      // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¨˜å·ã‚’é™¤å»
      const cleanText = stripMarkdown(text);
      console.log('[TTS] cleanText:', cleanText.substring(0, 50) + '...', 'æ–‡å­—æ•°:', cleanText.length);

      try {
        voiceStatus.innerHTML = t('voiceStatusSynthesizing');
        voiceStatus.className = 'voice-status speaking';

        const langConfig = LANGUAGE_CODE_MAP[currentLanguage];
        const response = await fetch(`${apiBase}/api/tts/synthesize`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: cleanText,
            language_code: langConfig.tts,
            voice_name: langConfig.voice
          })
        });

        const data = await response.json();

        console.log('[TTS] API ãƒ¬ã‚¹ãƒãƒ³ã‚¹å—ä¿¡:', data.success);
        if (data.success && data.audio) {
          const audio = new Audio(`data:audio/mp3;base64,${data.audio}`);
          currentAudio = audio;

          console.log('[TTS] éŸ³å£°å†ç”Ÿé–‹å§‹');

          // éŸ³å£°å†ç”Ÿå®Œäº†ã‚’å¾…ã¤Promiseã‚’ä½œæˆ
          const playPromise = new Promise<void>((resolve) => {
            audio.onended = () => {
              console.log('[TTS] éŸ³å£°å†ç”Ÿå®Œäº†');
              voiceStatus.innerHTML = t('voiceStatusStopped');
              voiceStatus.className = 'voice-status stopped';
              currentAudio = null;
              resolve();
            };

            audio.onerror = () => {
              console.log('[TTS] éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼');
              voiceStatus.innerHTML = t('voiceStatusStopped');
              voiceStatus.className = 'voice-status stopped';
              resolve();
            };
          });

          if (isUserInteracted) {
            await audio.play();
            await playPromise; // å†ç”Ÿå®Œäº†ã‚’å¾…ã¤
          } else {
            showClickPrompt();
            voiceStatus.innerHTML = t('voiceStatusStopped');
            voiceStatus.className = 'voice-status stopped';
          }
        }
      } catch (error) {
        console.error('[TTS] Error:', error);
        voiceStatus.innerHTML = t('voiceStatusStopped');
        voiceStatus.className = 'voice-status stopped';
      }
    }

    // ç„¡éŸ³æ¤œå‡ºã®åœæ­¢
    function stopVAD() {
      if (vadCheckInterval) {
        clearInterval(vadCheckInterval);
        vadCheckInterval = null;
      }
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      analyser = null;
      hasSpoken = false;
    }

    // ç„¡éŸ³æ¤œå‡ºã«ã‚ˆã‚‹ã‚ªãƒ¼ãƒˆã‚¹ãƒˆãƒƒãƒ—
    function autoStopRecording() {
      console.log('[VAD] ç„¡éŸ³æ¤œå‡º - è‡ªå‹•åœæ­¢');
      stopVAD();
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
      if (recordingTimer) {
        clearTimeout(recordingTimer);
        recordingTimer = null;
      }
      isRecording = false;
      micBtn.classList.remove('recording');
      micBtn.innerHTML = 'ğŸ¤';
    }

    // éŒ²éŸ³åˆ‡ã‚Šæ›¿ãˆï¼ˆæ¡ˆ2: WebSocket Streaming STTå¯¾å¿œï¼‰
    async function toggleRecording() {
      enableAudioPlayback();
      stopCurrentAudio();

      if (isRecording) {
        // éŒ²éŸ³åœæ­¢
        stopStreamingSTT();
        return;
      }

      // WebSocket Streaming STT ãŒæœ‰åŠ¹ãªå ´åˆã¯ä½¿ç”¨ã€ç„¡åŠ¹ãªå ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      if (isStreamingSTT) {
        await startStreamingSTT();
      } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®MediaRecorderæ–¹å¼
        console.warn('[Recording] WebSocketæœªæ¥ç¶šã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½¿ç”¨');
        await startLegacyRecording();
      }
    }

    // WebSocket Streaming STTé–‹å§‹
    async function startStreamingSTT() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            channelCount: 1,
            sampleRate: 16000,  // 16kHz (Google Cloud STTæ¨å¥¨)
            echoCancellation: true,
            noiseSuppression: true
          }
        });

        // AudioContextä½œæˆï¼ˆ16kHzï¼‰
        audioContext = new AudioContext({ sampleRate: 16000 });
        const source = audioContext.createMediaStreamSource(stream);

        // AudioWorkletèª­ã¿è¾¼ã¿
        await audioContext.audioWorklet.addModule('/audio-processor.js');

        // AudioWorkletNodeä½œæˆ
        audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-processor');

        // PCMãƒãƒ£ãƒ³ã‚¯ã‚’WebSocketçµŒç”±ã§é€ä¿¡
        let chunkCount = 0;
        audioWorkletNode.port.onmessage = (event) => {
          const { audioChunk } = event.data;
          // Int16Array ã‚’base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
          const uint8Array = new Uint8Array(audioChunk.buffer);
          const base64 = btoa(String.fromCharCode.apply(null, Array.from(uint8Array)));

          // WebSocketé€ä¿¡
          if (socket && socket.connected) {
            socket.emit('audio_chunk', { chunk: base64 });
            chunkCount++;
            if (chunkCount % 10 === 0) {
              console.log(`[Audio] ãƒãƒ£ãƒ³ã‚¯é€ä¿¡: ${chunkCount}å€‹ (${audioChunk.length} samples)`);
            }
          } else {
            console.error('[Audio] WebSocketæœªæ¥ç¶š - ãƒãƒ£ãƒ³ã‚¯é€ä¿¡å¤±æ•—');
          }
        };

        // éŸ³å£°ãƒ•ãƒ­ãƒ¼æ¥ç¶š
        source.connect(audioWorkletNode);
        audioWorkletNode.connect(audioContext.destination);

        // VADã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆç„¡éŸ³æ¤œå‡ºï¼‰
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;
        source.connect(analyser);
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        hasSpoken = false;
        recordingStartTime = Date.now(); // éŒ²éŸ³é–‹å§‹æ™‚åˆ»ã‚’è¨˜éŒ²

        vadCheckInterval = window.setInterval(() => {
          if (!analyser || !isRecording) return;

          // æœ€å°éŒ²éŸ³æ™‚é–“ã«é”ã—ã¦ã„ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
          const elapsed = Date.now() - recordingStartTime;
          if (elapsed < MIN_RECORDING_TIME) {
            return;
          }

          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

          if (average > SILENCE_THRESHOLD) {
            hasSpoken = true;
            if (silenceTimer) {
              clearTimeout(silenceTimer);
              silenceTimer = null;
            }
            voiceStatus.innerHTML = t('voiceStatusRecording');
          } else if (hasSpoken && !silenceTimer) {
            voiceStatus.innerHTML = t('voiceStatusWaiting');
            silenceTimer = window.setTimeout(() => {
              console.log('[VAD] ç„¡éŸ³æ¤œå‡º - è‡ªå‹•åœæ­¢');
              stopStreamingSTT();
            }, SILENCE_DURATION);
          }
        }, 100);

        // WebSocketã‚¹ãƒˆãƒªãƒ¼ãƒ é–‹å§‹é€šçŸ¥
        const langConfig = LANGUAGE_CODE_MAP[currentLanguage];
        socket.emit('start_stream', { language_code: langConfig.stt });

        isRecording = true;
        micBtn.classList.add('recording');
        micBtn.innerHTML = 'â¹';
        voiceStatus.innerHTML = t('voiceStatusListening');
        voiceStatus.className = 'voice-status listening';

        console.log('[WebSocket STT] ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°éŒ²éŸ³é–‹å§‹');

        // 55ç§’å¾Œã«è‡ªå‹•åœæ­¢
        recordingTimer = window.setTimeout(() => {
          if (isRecording) {
            console.log('[Recording] æœ€å¤§éŒ²éŸ³æ™‚é–“ã«é”ã—ãŸãŸã‚è‡ªå‹•åœæ­¢');
            stopStreamingSTT();
            addMessage('system', t('recordingTimeLimit'));
          }
        }, MAX_RECORDING_TIME);

      } catch (error) {
        console.error('[WebSocket STT] éŒ²éŸ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
        addMessage('system', `${t('micAccessError')} ${(error as Error).message}`);
      }
    }

    // WebSocket Streaming STTåœæ­¢
    function stopStreamingSTT() {
      // VADåœæ­¢
      stopVAD();

      // AudioWorkletåœæ­¢
      if (audioWorkletNode) {
        audioWorkletNode.disconnect();
        audioWorkletNode = null;
      }

      // AudioContextåœæ­¢
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      // WebSocketã‚¹ãƒˆãƒªãƒ¼ãƒ åœæ­¢é€šçŸ¥
      if (socket && socket.connected) {
        socket.emit('stop_stream');
      }

      // ã‚¿ã‚¤ãƒãƒ¼åœæ­¢
      if (recordingTimer) {
        clearTimeout(recordingTimer);
        recordingTimer = null;
      }

      isRecording = false;
      micBtn.classList.remove('recording');
      micBtn.innerHTML = 'ğŸ¤';

      console.log('[WebSocket STT] ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°éŒ²éŸ³åœæ­¢');
    }

    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®MediaRecorderæ–¹å¼
    async function startLegacyRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });

        audioChunks = [];
        hasSpoken = false;
        recordingStartTime = Date.now(); // éŒ²éŸ³é–‹å§‹æ™‚åˆ»ã‚’è¨˜éŒ²

        // ç„¡éŸ³æ¤œå‡ºã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;
        source.connect(analyser);

        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        vadCheckInterval = window.setInterval(() => {
          if (!analyser || !isRecording) return;

          // æœ€å°éŒ²éŸ³æ™‚é–“ã«é”ã—ã¦ã„ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
          const elapsed = Date.now() - recordingStartTime;
          if (elapsed < MIN_RECORDING_TIME) {
            return;
          }

          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

          if (average > SILENCE_THRESHOLD) {
            hasSpoken = true;
            if (silenceTimer) {
              clearTimeout(silenceTimer);
              silenceTimer = null;
            }
            voiceStatus.innerHTML = t('voiceStatusRecording');
          } else if (hasSpoken && !silenceTimer) {
            voiceStatus.innerHTML = t('voiceStatusWaiting');
            silenceTimer = window.setTimeout(() => {
              autoStopRecording();
            }, SILENCE_DURATION);
          }
        }, 100);

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          stopVAD();
          stream.getTracks().forEach(track => track.stop());

          if (recordingTimer) {
            clearTimeout(recordingTimer);
            recordingTimer = null;
          }

          if (audioChunks.length > 0) {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            await transcribeAudio(audioBlob);
          }
        };

        mediaRecorder.start();
        isRecording = true;
        micBtn.classList.add('recording');
        micBtn.innerHTML = 'â¹';
        voiceStatus.innerHTML = t('voiceStatusListening');
        voiceStatus.className = 'voice-status listening';

        recordingTimer = window.setTimeout(() => {
          if (isRecording && mediaRecorder && mediaRecorder.state === 'recording') {
            console.log('[Recording] æœ€å¤§éŒ²éŸ³æ™‚é–“ã«é”ã—ãŸãŸã‚è‡ªå‹•åœæ­¢');
            stopVAD();
            mediaRecorder.stop();
            isRecording = false;
            micBtn.classList.remove('recording');
            micBtn.innerHTML = 'ğŸ¤';
            addMessage('system', t('recordingTimeLimit'));
          }
        }, MAX_RECORDING_TIME);

      } catch (error) {
        console.error('[Recording] Error:', error);
        addMessage('system', `${t('micAccessError')} ${(error as Error).message}`);
      }
    }

    // éŸ³å£°èªè­˜
    async function transcribeAudio(audioBlob: Blob) {
      try {
        voiceStatus.innerHTML = t('voiceStatusRecognizing');
        voiceStatus.className = 'voice-status';

        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);

        reader.onloadend = async () => {
          const base64Audio = (reader.result as string).split(',')[1];
          // ä¸€æ™‚çš„ã«ãƒãƒƒãƒSTTã«æˆ»ã™ï¼ˆå‹•ä½œç¢ºèªç”¨ï¼‰
          const langConfig = LANGUAGE_CODE_MAP[currentLanguage];
          const response = await fetch(`${apiBase}/api/stt/transcribe`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              audio: base64Audio,
              language_code: langConfig.stt
            })
          });
          const data = await response.json();

          if (data.success && data.transcript) {
            userInput.value = data.transcript;
            voiceStatus.innerHTML = t('voiceStatusComplete');
            voiceStatus.className = 'voice-status';

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
            addMessage('user', data.transcript);

            // ç¬¬1æ®µéšï¼šå³ç­”
            const ack = selectSmartAcknowledgment(data.transcript);
            console.log(`[å³ç­”] ${ack.logText}`);

            const preGeneratedAudio = preGeneratedAcks.get(ack.text);
            if (preGeneratedAudio && isTTSEnabled && isUserInteracted) {
              // äº‹å‰ç”ŸæˆéŸ³å£°ã‚’å³åº§ã«å†ç”Ÿï¼ˆTTSãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸è¦ï¼ï¼‰
              const audio = new Audio(`data:audio/mp3;base64,${preGeneratedAudio}`);
              currentAudio = audio;

              audio.onended = () => {
                currentAudio = null;
              };

              audio.play().catch(err => {
                console.error('[å³ç­”] éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼:', err);
              });
              console.log(`[å³ç­”] äº‹å‰ç”ŸæˆéŸ³å£°ã‚’å†ç”Ÿ: "${ack.text}"`);
            } else if (isTTSEnabled) {
              // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: äº‹å‰ç”ŸæˆãŒãªã„å ´åˆã¯ãã®å ´ã§ç”Ÿæˆ
              console.log(`[å³ç­”] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãã®å ´ã§ç”Ÿæˆ "${ack.text}"`);
              speakTextGCP(ack.text, false);
            }

            // ãƒãƒ£ãƒƒãƒˆã«å³ç­”ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
            addMessage('assistant', ack.text);

            // ç¬¬2æ®µéšï¼šã‚·ãƒ³ãƒ—ãƒ«ãªã‚ªã‚¦ãƒ è¿”ã—å¿œç­”
            const fallbackResponse = generateFallbackResponse(data.transcript);
            if (isTTSEnabled && isUserInteracted) {
              await speakTextGCP(fallbackResponse, false);
            }
            addMessage('assistant', fallbackResponse);

            // 3ç§’å¾Œã«è¿½åŠ ã®å¿œç­”ã‚’å†ç”Ÿ
            setTimeout(async () => {
              const additionalResponse = t('additionalResponse');
              if (isTTSEnabled && isUserInteracted) {
                await speakTextGCP(additionalResponse, false);
              }
              addMessage('assistant', additionalResponse);
            }, 3000);

            // ä¸¦åˆ—ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ï¼ˆå¾…ãŸãªã„ï¼‰
            if (!isRecording && userInput.value.trim()) {
              isFromVoiceInput = true; // ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
              sendMessage(); // awaitã—ãªã„ = ä¸¦åˆ—å®Ÿè¡Œ
            }

            voiceStatus.innerHTML = t('voiceStatusStopped');
            voiceStatus.className = 'voice-status stopped';
          } else {
            voiceStatus.innerHTML = t('voiceNotRecognized');
          }
        };

      } catch (error) {
        console.error('[STT] Error:', error);
        addMessage('system', `${t('sttError')} ${(error as Error).message}`);
        voiceStatus.innerHTML = t('voiceStatusStopped');
        voiceStatus.className = 'voice-status stopped';
      }
    }

    // ã‚¹ãƒãƒ¼ãƒˆå³ç­”é¸æŠï¼ˆæ¡ˆ3: test_voice_conversation.pyæº–æ‹ ï¼‰
    function selectSmartAcknowledgment(userMessage: string): { text: string, logText: string } {
      const messageLower = userMessage.trim();
      // è³ªå•å½¢å¼ï¼ˆæ˜ç¢ºãªç–‘å•æ–‡ï¼‰- æ—¥æœ¬èªã®ã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã€ä»–è¨€èªã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
      if (currentLanguage === 'ja' && /ã”ã–ã„ã¾ã™ã‹|ã§ã—ã‚‡ã†ã‹|ã„ã‹ãŒã§ã™ã‹|ã‚ã‚Šã¾ã™ã‹/.test(messageLower)) {
        return {
          text: t('ackConfirm'),
          logText: `è³ªå•å½¢å¼ â†’ ã€Œ${t('ackConfirm')}ã€`
        };
      }

      // å ´æ‰€ãƒ»ã‚¨ãƒªã‚¢ã®è³ªå•
      if (currentLanguage === 'ja' && /ã©ã“|å ´æ‰€|ã‚¨ãƒªã‚¢|åœ°åŸŸ|é§…/.test(messageLower)) {
        return {
          text: t('ackSearch'),
          logText: `å ´æ‰€ã®è³ªå• â†’ ã€Œ${t('ackSearch')}ã€`
        };
      }

      // æ¤œç´¢ãƒ»æ¢ã™
      if (currentLanguage === 'ja' && /æ¢ã—ã¦|æ¢ã—|æ•™ãˆã¦|ãŠã™ã™ã‚|ç´¹ä»‹/.test(messageLower)) {
        return {
          text: t('ackUnderstood'),
          logText: `æ¤œç´¢ä¾é ¼ â†’ ã€Œ${t('ackUnderstood')}ã€`
        };
      }

      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ã‚·ãƒ³ãƒ—ãƒ«ãªç¢ºèª
      return {
        text: t('ackYes'),
        logText: `ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ â†’ ã€Œ${t('ackYes')}ã€`
      };
    }

    // TTSåˆ‡ã‚Šæ›¿ãˆ
    function toggleTTS() {
      if (!isUserInteracted) {
        enableAudioPlayback();
        return;
      }

      enableAudioPlayback();
      isTTSEnabled = !isTTSEnabled;
      speakerBtn.innerHTML = isTTSEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
      speakerBtn.title = isTTSEnabled ? t('btnTTSOn') : t('btnTTSOff');
      speakerBtn.className = isTTSEnabled ? 'btn btn-icon btn-speaker' : 'btn btn-icon btn-speaker disabled';

      if (!isTTSEnabled) {
        stopCurrentAudio();
      }
    }

    // ã‚·ãƒ³ãƒ—ãƒ«ãªã‚ªã‚¦ãƒ è¿”ã—å¿œç­”
    function generateFallbackResponse(text: string): string {
      return t('fallbackResponse', text);
    }

    // åˆæœŸåŒ–
    async function initialize() {
      try {
        const response = await fetch(`${apiBase}/api/session/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_info: {},
            language: currentLanguage
          })
        });

        const data = await response.json();
        sessionId = data.session_id;

        // ãƒ­ãƒ¼ã‚«ãƒ«i18nã‹ã‚‰åˆæœŸæŒ¨æ‹¶ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆè¨€èªåˆ‡ã‚Šæ›¿ãˆå¯¾å¿œï¼‰
        addMessage('assistant', t('initialGreeting'), null, true);

        // æ¡ˆ1: å³ç­”ç”¨éŸ³å£°ã‚’äº‹å‰ç”Ÿæˆï¼ˆä¸¦åˆ—å®Ÿè¡Œï¼‰
        console.log('[åˆæœŸåŒ–] å³ç­”ç”¨éŸ³å£°ã‚’äº‹å‰ç”Ÿæˆä¸­...');
        const ackTexts = [
          t('ackConfirm'),
          t('ackSearch'),
          t('ackUnderstood'),
          t('ackYes'),
          t('ttsIntro')
        ];
        const langConfig = LANGUAGE_CODE_MAP[currentLanguage];
        const ackPromises = ackTexts.map(async (text) => {
          try {
            const ackResponse = await fetch(`${apiBase}/api/tts/synthesize`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text: text,
                language_code: langConfig.tts,
                voice_name: langConfig.voice
              })
            });
            const ackData = await ackResponse.json();
            if (ackData.success && ackData.audio) {
              preGeneratedAcks.set(text, ackData.audio);
              console.log(`[åˆæœŸåŒ–] âœ… äº‹å‰ç”Ÿæˆå®Œäº†: "${text}"`);
            }
          } catch (error) {
            console.error(`[åˆæœŸåŒ–] äº‹å‰ç”Ÿæˆå¤±æ•—: "${text}"`, error);
          }
        });

        // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®TTSã¨ä¸¦åˆ—å®Ÿè¡Œ
        await Promise.all([
          speakTextGCP(t('initialGreeting')),
          ...ackPromises
        ]);

        userInput.disabled = false;
        sendBtn.disabled = false;
        micBtn.disabled = false;
        speakerBtn.disabled = false;
        userInput.focus();

        console.log(`[åˆæœŸåŒ–] å®Œäº† (äº‹å‰ç”ŸæˆéŸ³å£°: ${preGeneratedAcks.size}ä»¶)`);

        // â˜…â˜…â˜… ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ã‚¹ã‚¯ãƒªãƒ¼ãƒ³çµ‚äº† â˜…â˜…â˜…
        if (splashOverlay && !splashOverlay.classList.contains('hidden')) {
          hideSplash();
        }

        // æ¡ˆ2: WebSocket Streaming STTæ¥ç¶šã‚’åˆæœŸåŒ–
        initializeWebSocketSTT();

        // UIè¨€èªã‚’åˆæœŸåŒ–
        updateUILanguage();

      } catch (error) {
        console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        showError(t('initError'));
      }
    }

    // WebSocket Streaming STTæ¥ç¶šåˆæœŸåŒ–ï¼ˆæ¡ˆ2: å®Œå…¨å®Ÿè£…ï¼‰
    function initializeWebSocketSTT() {
      try {
        // Socket.IOæ¥ç¶šï¼ˆapiBaseã‹ã‚‰WebSocketã‚µãƒ¼ãƒãƒ¼URLã‚’ç”Ÿæˆï¼‰
        const wsUrl = apiBase || window.location.origin;
        socket = io(wsUrl);

        socket.on('connect', () => {
          console.log('[WebSocket STT] æ¥ç¶šæˆåŠŸ');
          isStreamingSTT = true;
        });

        socket.on('disconnect', () => {
          console.log('[WebSocket STT] åˆ‡æ–­');
          isStreamingSTT = false;
        });

        socket.on('connected', (data: any) => {
          console.log('[WebSocket STT] ã‚µãƒ¼ãƒãƒ¼æº–å‚™å®Œäº†:', data);
        });

        socket.on('stream_started', (data: any) => {
          console.log('[WebSocket STT] ã‚¹ãƒˆãƒªãƒ¼ãƒ é–‹å§‹:', data);
        });

        socket.on('transcript', (data: any) => {
          // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ èªè­˜çµæœ
          const { text, is_final, confidence } = data;

          if (is_final) {
            // æœ€çµ‚çµæœ: ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã¨ã—ã¦ç¢ºå®š
            console.log(`[WebSocket STT] æœ€çµ‚èªè­˜: "${text}" (ä¿¡é ¼åº¦: ${confidence.toFixed(2)})`);
            streamingTranscript = text;

            // éŸ³å£°èªè­˜å®Œäº†å‡¦ç†
            handleStreamingSTTComplete(text);
          } else {
            // é€”ä¸­çµæœ: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º
            console.log(`[WebSocket STT] é€”ä¸­èªè­˜: "${text}"`);
            userInput.value = text; // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å…¥åŠ›æ¬„ã«è¡¨ç¤º
          }
        });

        socket.on('stream_stopped', (data: any) => {
          console.log('[WebSocket STT] ã‚¹ãƒˆãƒªãƒ¼ãƒ åœæ­¢:', data);
        });

        socket.on('error', (data: any) => {
          console.error('[WebSocket STT] ã‚¨ãƒ©ãƒ¼:', data.message);
          addMessage('system', `${t('sttError')} ${data.message}`);
        });

      } catch (error) {
        console.error('[WebSocket STT] åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        isStreamingSTT = false;
      }
    }

    // WebSocket Streaming STTå®Œäº†å‡¦ç†
    function handleStreamingSTTComplete(transcript: string) {
      // ã¾ãšã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚’å®Œå…¨åœæ­¢
      stopStreamingSTT();
      voiceStatus.innerHTML = t('voiceStatusComplete');
      voiceStatus.className = 'voice-status';

      // å…¥åŠ›æ¬„ã«èªè­˜çµæœã‚’è¨­å®š
      userInput.value = transcript;

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
      addMessage('user', transcript);

      // ç¬¬1æ®µéšï¼šå³ç­”
      const ack = selectSmartAcknowledgment(transcript);
      console.log(`[å³ç­”] ${ack.logText}`);

      const preGeneratedAudio = preGeneratedAcks.get(ack.text);
      let firstAckPromise: Promise<void> | null = null;
      if (preGeneratedAudio && isTTSEnabled && isUserInteracted) {
        // äº‹å‰ç”ŸæˆéŸ³å£°ã‚’å³åº§ã«å†ç”Ÿï¼ˆTTSãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸è¦ï¼ï¼‰
        firstAckPromise = new Promise<void>((resolve) => {
          const audio = new Audio(`data:audio/mp3;base64,${preGeneratedAudio}`);
          currentAudio = audio;

          audio.onended = () => {
            currentAudio = null;
            resolve();
          };

          audio.play().catch(err => {
            console.error('[å³ç­”] éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼:', err);
            resolve();
          });
        });
        console.log(`[å³ç­”] äº‹å‰ç”ŸæˆéŸ³å£°ã‚’å†ç”Ÿ: "${ack.text}"`);
      } else if (isTTSEnabled) {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: äº‹å‰ç”ŸæˆãŒãªã„å ´åˆã¯ãã®å ´ã§ç”Ÿæˆ
        console.log(`[å³ç­”] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãã®å ´ã§ç”Ÿæˆ "${ack.text}"`);
        firstAckPromise = speakTextGCP(ack.text, false);
      }

      // ãƒãƒ£ãƒƒãƒˆã«å³ç­”ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
      addMessage('assistant', ack.text);

      // éŒ²éŸ³ã‚’åœæ­¢
      stopStreamingSTT();

      // ç¬¬2æ®µéšï¼šã‚·ãƒ³ãƒ—ãƒ«ãªã‚ªã‚¦ãƒ è¿”ã—å¿œç­”
      (async () => {
        try {
          // ç¬¬1æ®µéšã®å³ç­”ãŒçµ‚ã‚ã‚‹ã®ã‚’å¾…ã¤
          if (firstAckPromise) {
            await firstAckPromise;
          }

          // ã‚·ãƒ³ãƒ—ãƒ«ãªã‚ªã‚¦ãƒ è¿”ã—å¿œç­”
          const fallbackResponse = generateFallbackResponse(transcript);
          console.log(`[ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¿œç­”] "${transcript}" â†’ "${fallbackResponse}"`);

          if (isTTSEnabled && isUserInteracted) {
            await speakTextGCP(fallbackResponse, false);
          }
          addMessage('assistant', fallbackResponse);

          // 5ç§’å¾Œã«è¿½åŠ ã®å¿œç­”ã‚’å†ç”Ÿ
          setTimeout(async () => {
            const additionalResponse = t('additionalResponse');
            if (isTTSEnabled && isUserInteracted) {
              await speakTextGCP(additionalResponse, false);
            }
            addMessage('assistant', additionalResponse);
          }, 5000);

          // ä¸¦åˆ—ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
          if (userInput.value.trim()) {
            isFromVoiceInput = true;
            sendMessage();
          }

        } catch (error) {
          console.error('ç¬¬2æ®µéšå¿œç­”ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
          // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚·ãƒ³ãƒ—ãƒ«ãªå¿œç­”ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          const fallbackResponse = generateFallbackResponse(transcript);
          if (isTTSEnabled && isUserInteracted) {
            await speakTextGCP(fallbackResponse, false);
          }
          addMessage('assistant', fallbackResponse);
          if (userInput.value.trim()) {
            isFromVoiceInput = true;
            sendMessage();
          }
        }
      })();

      voiceStatus.innerHTML = t('voiceStatusStopped');
      voiceStatus.className = 'voice-status stopped';
    }

    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚·ãƒ§ãƒƒãƒ—æƒ…å ±ã‚’æŠ½å‡º
    function extractShopsFromResponse(text: string): any[] {
      const shops: any[] = [];
      // ãƒ‘ã‚¿ãƒ¼ãƒ³: ç•ªå·. **åº—åï¼ˆèª­ã¿ï¼‰**: èª¬æ˜
      // ã¾ãŸã¯: ç•ªå·. **åº—å**: èª¬æ˜
      const pattern = /(\d+)\.\s*\*\*([^*]+)\*\*[ï¼š:]\s*([^\n]+)/g;
      let match;

      console.log('[ShopExtract] ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚·ãƒ§ãƒƒãƒ—ã‚’æŠ½å‡ºä¸­...');
      while ((match = pattern.exec(text)) !== null) {
        const fullName = match[2].trim();
        const description = match[3].trim();

        // åº—åã‹ã‚‰èª­ã¿ä»®åã‚’åˆ†é›¢
        let name = fullName;
        let reading = '';

        const nameMatch = fullName.match(/^([^ï¼ˆ(]+)[ï¼ˆ(]([^ï¼‰)]+)[ï¼‰)]/);
        if (nameMatch) {
          name = nameMatch[1].trim();
          reading = nameMatch[2].trim();
        }

        // åº—åã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦URLã‚’ç”Ÿæˆ
        const encodedName = encodeURIComponent(name);
        shops.push({
          name: name,
          description: description,
          category: 'ã‚¤ã‚¿ãƒªã‚¢ãƒ³',
          // æ¤œç´¢ç”¨URLã‚’ç”Ÿæˆ
          hotpepper_url: `https://www.hotpepper.jp/SA11/srchRS/?keyword=${encodedName}`,
          maps_url: `https://www.google.com/maps/search/${encodedName}`,
          tabelog_url: `https://tabelog.com/rstLst/?vs=1&sa=&sk=${encodedName}`
        });
      }

      console.log(`[ShopExtract] ${shops.length}ä»¶ã®ã‚·ãƒ§ãƒƒãƒ—ã‚’æŠ½å‡º:`, shops);

      return shops;
    }

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
    async function sendMessage() {
      let firstAckPromise: Promise<void> | null = null; // âœ¨ å³ç­”å¾…æ©Ÿç”¨Promise

      const message = userInput.value.trim();
      if (!message || isProcessing) return;
      isProcessing = true;
      sendBtn.disabled = true;
      micBtn.disabled = true;
      userInput.disabled = true;

      // ãƒ†ã‚­ã‚¹ãƒˆé€ä¿¡ã®å ´åˆã®ã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
      // ï¼ˆéŸ³å£°ã®å ´åˆã¯transcribeAudio()ã§æ—¢ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¿½åŠ æ¸ˆã¿ï¼‰
      if (!isFromVoiceInput) {
        addMessage('user', message);
      }
      userInput.value = '';

      // æ¡ˆ1: å³ç­”ã¯ transcribeAudio() ã§æ—¢ã«å†ç”Ÿæ¸ˆã¿ï¼ˆéŸ³å£°å…¥åŠ›ã®å ´åˆï¼‰
      // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®å ´åˆã®ã¿ã“ã“ã§å³ç­”ã‚’ç”Ÿæˆ
      if (!isFromVoiceInput) {
        console.log(`[DEBUG] ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®å³ç­”å‡¦ç†ã‚’é–‹å§‹`);
        const ack = selectSmartAcknowledgment(message);
        console.log(`[DEBUG] å³ç­”ãƒ†ã‚­ã‚¹ãƒˆ: "${ack.text}"`);

        // ãƒãƒ£ãƒƒãƒˆã«å³ç­”ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
        addMessage('assistant', ack.text);

        // éŸ³å£°å†ç”Ÿå‡¦ç†
        if (isTTSEnabled) {
          try {
            const preGeneratedAudio = preGeneratedAcks.get(ack.text);
            if (preGeneratedAudio && isUserInteracted) {
              console.log(`[DEBUG] äº‹å‰ç”ŸæˆéŸ³å£°ã‚’å†ç”Ÿã—ã¾ã™`);
              // âœ¨ éŸ³å£°å†ç”Ÿå®Œäº†ã‚’å¾…ã¦ã‚‹ã‚ˆã†ã«PromiseåŒ–
              firstAckPromise = new Promise<void>((resolve) => {
                const audio = new Audio(`data:audio/mp3;base64,${preGeneratedAudio}`);
                currentAudio = audio;
                audio.onended = () => {
                  console.log(`[DEBUG] äº‹å‰ç”ŸæˆéŸ³å£°ã®å†ç”ŸãŒå®Œäº†ã—ã¾ã—ãŸ`);
                  currentAudio = null;
                  resolve();  // å†ç”Ÿå®Œäº†ã‚’é€šçŸ¥
                };
                audio.play().catch(err => {
                  console.error('[å³ç­”] éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼:', err);
                  resolve();  // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ç¶šè¡Œ
                });
              });
            } else {
              console.log(`[DEBUG] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯éŸ³å£°ã‚’å†ç”Ÿã—ã¾ã™`);
              // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ™‚ã‚‚PromiseåŒ–
              firstAckPromise = speakTextGCP(ack.text, false);
            }
          } catch (error) {
            console.error(`[DEBUG] éŸ³å£°å†ç”Ÿã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:`, error);
          }
        }

        // ç¬¬1æ®µéšã®å³ç­”ãŒçµ‚ã‚ã‚‹ã®ã‚’å¾…ã¤
        if (firstAckPromise) {
          await firstAckPromise;
        }

        // ç¬¬2æ®µéšï¼šã‚·ãƒ³ãƒ—ãƒ«ãªã‚ªã‚¦ãƒ è¿”ã—å¿œç­”
        const fallbackResponse = generateFallbackResponse(message);
        console.log(`[DEBUG] ç¬¬2æ®µéšå¿œç­”: "${fallbackResponse}"`);
        if (isTTSEnabled && isUserInteracted) {
          await speakTextGCP(fallbackResponse, false);
        }
        addMessage('assistant', fallbackResponse);

        // 3ç§’å¾Œã«è¿½åŠ ã®å¿œç­”ã‚’å†ç”Ÿ
        setTimeout(async () => {
          const additionalResponse = t('additionalResponse');
          console.log(`[DEBUG] è¿½åŠ å¿œç­”: "${additionalResponse}"`);
          if (isTTSEnabled && isUserInteracted) {
            await speakTextGCP(additionalResponse, false);
          }
          addMessage('assistant', additionalResponse);
        }, 3000);
      }

      // ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
      const wasVoiceInput = isFromVoiceInput;
      isFromVoiceInput = false;

      // â˜…â˜…â˜… è¿½åŠ : 4ç§’å¾Œã«å‹•ç”»ã‚’è¡¨ç¤ºã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚»ãƒƒãƒˆ â˜…â˜…â˜…
      // â€»ã€ŒãŠåº—ã®æƒ…å ±ã‚’ç¢ºèªä¸­ã§ã™...ã€ã®éŸ³å£°é–‹å§‹(ç´„5ç§’å¾Œ)ã«åˆã‚ã›ã¦è¡¨ç¤º
      if (waitOverlayTimer) clearTimeout(waitOverlayTimer);
      waitOverlayTimer = window.setTimeout(() => {
        showWaitOverlay();
      }, 6000);

      try {
        // const loadingId = addLoadingMessage(); // â˜…å‹•ç”»ã‚’ä½¿ã†ã®ã§ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å¹ãå‡ºã—ã¯OFFæ¨å¥¨
        
        const response = await fetch(`${apiBase}/api/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: sessionId,
            message: message,
            stage: currentStage,
            language: currentLanguage
          })
        });

        const data = await response.json();

        // removeLoadingMessage(loadingId); // â˜…OFFã«ã—ãŸå ´åˆã¯ã“ã“ã‚‚ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ

        // â˜…â˜…â˜… è¿½åŠ : ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒæ¥ãŸã‚‰å‹•ç”»ã‚’æ¶ˆã™ â˜…â˜…â˜…
        hideWaitOverlay();

        // ãƒ‡ãƒãƒƒã‚°: ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹ã‚’ç¢ºèª
        console.log('[DEBUG] data.response æ–‡å­—æ•°:', data.response.length);
        console.log('[DEBUG] data.response å†…å®¹:', data.response);
        console.log('[DEBUG] data.summary:', data.summary);

        // æœ¬æ–‡ã‚’è¡¨ç¤ºï¼ˆsummaryã‚‚ä¿å­˜ã™ã‚‹ãŒèª­ã¿ä¸Šã’ã¯responseã®ã¿ï¼‰
        addMessage('assistant', data.response, data.summary);

        // å…ˆè¡ŒTTSã‚’åœæ­¢
        stopCurrentAudio();

        // ã‚·ãƒ§ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®æœ‰ç„¡ã§èª­ã¿ä¸Šã’å†…å®¹ã‚’å¤‰ãˆã‚‹
        if (data.shops && data.shops.length > 0) {
          // ã‚·ãƒ§ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã€äºˆç´„ä¾é ¼ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
          currentShops = data.shops;
          reservationBtn.disabled = false;

          // âœ… ã¾ãšã‚·ãƒ§ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚’æœ€å„ªå…ˆï¼ˆTTSå‰ã«å³åº§ã«å®Ÿè¡Œï¼‰
          const event = new CustomEvent('displayShops', {
            detail: { shops: data.shops, language: currentLanguage }
          });
          document.dispatchEvent(event);

          // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
          const section = document.getElementById('shopListSection');
          if (section) {
            section.classList.add('has-shops');
          }

          // âœ… TTSã¯éåŒæœŸã§ä¸¦åˆ—å®Ÿè¡Œï¼ˆawait ã—ãªã„ = ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ï¼‰
          (async () => {
            try {
              // ãƒ‘ãƒ¼ãƒˆ1ï¼šå®šå‹æ–‡ã‚’å³åº§ã«å†ç”Ÿ
              await speakTextGCP(t('ttsIntro'));

              // LLMã®å¿œç­”ã‚’è§£æã—ã¦å®šå‹æ–‡ã¨åº—èˆ—æƒ…å ±ã‚’åˆ†é›¢
              const lines = data.response.split('\n\n');
              let introText = "";
              let shopLines = lines;

              // æœ€åˆã®è¡ŒãŒå®šå‹æ–‡ã‹ãƒã‚§ãƒƒã‚¯
              if (lines[0].includes('ã”å¸Œæœ›ã«åˆã†ãŠåº—') && lines[0].includes('ã”ç´¹ä»‹ã—ã¾ã™')) {
                introText = lines[0]; // å®šå‹æ–‡ã‚’æŠ½å‡º
                shopLines = lines.slice(1); // æ®‹ã‚ŠãŒåº—èˆ—æƒ…å ±
              }

              // ãƒ‘ãƒ¼ãƒˆ2ï¼šå®šå‹æ–‡ã‚’äº‹å‰ç”ŸæˆéŸ³å£°ã‹ã‚‰å³æ™‚å†ç”Ÿ
              let introPart2Promise: Promise<void> | null = null;
              if (introText && isTTSEnabled && isUserInteracted) {
                const preGeneratedIntro = preGeneratedAcks.get(introText);
                if (preGeneratedIntro) {
                  introPart2Promise = new Promise<void>((resolve) => {
                    const audio = new Audio(`data:audio/mp3;base64,${preGeneratedIntro}`);
                    currentAudio = audio;
                    audio.onended = () => {
                      currentAudio = null;
                      resolve();
                    };
                    audio.play();
                  });
                } else {
                  introPart2Promise = speakTextGCP(introText, false);
                }
              }

              // ãƒ‘ãƒ¼ãƒˆ3ï¼š1è»’ç›® + 2è»’ç›®ä»¥é™ã‚’ä¸¦è¡Œã—ã¦éŸ³å£°åˆæˆé–‹å§‹
              let firstShopAudioPromise: Promise<string | null> | null = null;
              let remainingAudioPromise: Promise<string | null> | null = null;

              if (shopLines.length > 0 && isTTSEnabled && isUserInteracted) {
                const firstShop = shopLines[0];
                const restShops = shopLines.slice(1).join('\n\n');

                // â© 1è»’ç›®ã®éŸ³å£°åˆæˆã‚’å³åº§ã«é–‹å§‹ï¼ˆä¸¦è¡Œå‡¦ç†ï¼‰
                const shopLangConfig = LANGUAGE_CODE_MAP[currentLanguage];
                firstShopAudioPromise = (async () => {
                  const cleanText = stripMarkdown(firstShop);
                  const response = await fetch(`${apiBase}/api/tts/synthesize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      text: cleanText,
                      language_code: shopLangConfig.tts,
                      voice_name: shopLangConfig.voice
                    })
                  });
                  const result = await response.json();
                  return result.success ? `data:audio/mp3;base64,${result.audio}` : null;
                })();

                // â© 2è»’ç›®ä»¥é™ã‚‚åŒæ™‚ã«éŸ³å£°åˆæˆé–‹å§‹ï¼ˆä¸¦è¡Œå‡¦ç†ï¼‰
                if (restShops) {
                  remainingAudioPromise = (async () => {
                    const cleanText = stripMarkdown(restShops);
                    const response = await fetch(`${apiBase}/api/tts/synthesize`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({
                        text: cleanText,
                        language_code: shopLangConfig.tts,
                        voice_name: shopLangConfig.voice
                      })
                    });
                    const result = await response.json();
                    return result.success ? `data:audio/mp3;base64,${result.audio}` : null;
                  })();
                }
              }

              // ãƒ‘ãƒ¼ãƒˆ2ã®å†ç”Ÿå®Œäº†ã‚’å¾…ã¤
              if (introPart2Promise) {
                await introPart2Promise;
              }

              // 1è»’ç›®ã®éŸ³å£°åˆæˆå®Œäº†ã‚’å¾…ã£ã¦å†ç”Ÿ
              if (firstShopAudioPromise) {
                const firstShopAudio = await firstShopAudioPromise;
                if (firstShopAudio) {
                  stopCurrentAudio();
                  const audio = new Audio(firstShopAudio);
                  currentAudio = audio;
                  // 1è»’ç›®ã®å†ç”Ÿå®Œäº†ã‚’å¾…ã¤
                  await new Promise<void>((resolve) => {
                    audio.onended = () => {
                      currentAudio = null;
                      voiceStatus.innerHTML = t('voiceStatusStopped');
                      voiceStatus.className = 'voice-status stopped';
                      resolve();
                    };

                    voiceStatus.innerHTML = t('voiceStatusSpeaking');
                    voiceStatus.className = 'voice-status speaking';

                    audio.play();
                  });

                  // 2è»’ç›®ä»¥é™ã®éŸ³å£°åˆæˆå®Œäº†ã‚’å¾…ã£ã¦å†ç”Ÿ
                  if (remainingAudioPromise) {
                    const remainingAudio = await remainingAudioPromise;
                    if (remainingAudio) {
                      await new Promise(resolve => setTimeout(resolve, 500));

                      stopCurrentAudio();
                      const audioElement = new Audio(remainingAudio);
                      currentAudio = audioElement;

                      await new Promise<void>((resolve) => {
                        audioElement.onended = () => {
                          currentAudio = null;
                          voiceStatus.innerHTML = 'ğŸ¤ éŸ³å£°èªè­˜: åœæ­¢ä¸­';
                          voiceStatus.className = 'voice-status stopped';
                          resolve();
                        };

                        voiceStatus.innerHTML = 'ğŸ”Š éŸ³å£°å†ç”Ÿä¸­...';
                        voiceStatus.className = 'voice-status speaking';

                        audioElement.play();
                      });
                    }
                  }
                }
              }
            } catch (error) {
              console.error('[TTS] ã‚·ãƒ§ãƒƒãƒ—æƒ…å ±èª­ã¿ä¸Šã’ã‚¨ãƒ©ãƒ¼:', error);
            }
          })();
          // âœ… å³åº§ã«å®Ÿè¡Œã™ã‚‹ãŒã€å®Œäº†ã‚’å¾…ãŸãªã„

        } else {
          // ã‚·ãƒ§ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã®å‡¦ç†
          if (data.response) {
            // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ã‚·ãƒ§ãƒƒãƒ—æƒ…å ±ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦æŠ½å‡ºã‚’è©¦ã¿ã‚‹
            const extractedShops = extractShopsFromResponse(data.response);
            if (extractedShops.length > 0) {
              // ã‚·ãƒ§ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã€äºˆç´„ä¾é ¼ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
              currentShops = extractedShops;
              reservationBtn.disabled = false;

              // âœ… ã¾ãšã‚·ãƒ§ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚’æœ€å„ªå…ˆï¼ˆTTSå‰ã«å³åº§ã«å®Ÿè¡Œï¼‰
              const event = new CustomEvent('displayShops', {
                detail: { shops: extractedShops, language: currentLanguage }
              });
              document.dispatchEvent(event);

              const section = document.getElementById('shopListSection');
              if (section) {
                section.classList.add('has-shops');
              }
              // âœ… TTSã¯éåŒæœŸã§ä¸¦åˆ—å®Ÿè¡Œï¼ˆawait ã—ãªã„ï¼‰
              (async () => {
                try {
                  // ãƒ‘ãƒ¼ãƒˆ1ï¼šå®šå‹æ–‡ã‚’å³åº§ã«å†ç”Ÿ
                  await speakTextGCP(t('ttsIntro'));

                  // LLMã®å¿œç­”ã‚’è§£æã—ã¦å®šå‹æ–‡ã¨åº—èˆ—æƒ…å ±ã‚’åˆ†é›¢
                  const lines = data.response.split('\n\n');
                  let introText = "";
                  let shopLines = lines;

                  // æœ€åˆã®è¡ŒãŒå®šå‹æ–‡ã‹ãƒã‚§ãƒƒã‚¯
                  if (lines[0].includes('ã”å¸Œæœ›ã«åˆã†ãŠåº—') && lines[0].includes('ã”ç´¹ä»‹ã—ã¾ã™')) {
                    introText = lines[0]; // å®šå‹æ–‡ã‚’æŠ½å‡º
                    shopLines = lines.slice(1); // æ®‹ã‚ŠãŒåº—èˆ—æƒ…å ±
                  }

                  // ãƒ‘ãƒ¼ãƒˆ2ï¼šå®šå‹æ–‡ã‚’äº‹å‰ç”ŸæˆéŸ³å£°ã‹ã‚‰å³æ™‚å†ç”Ÿ
                  let introPart2Promise: Promise<void> | null = null;
                  if (introText && isTTSEnabled && isUserInteracted) {
                    const preGeneratedIntro = preGeneratedAcks.get(introText);
                    if (preGeneratedIntro) {
                      introPart2Promise = new Promise<void>((resolve) => {
                        const audio = new Audio(`data:audio/mp3;base64,${preGeneratedIntro}`);
                        currentAudio = audio;
                        audio.onended = () => {
                          currentAudio = null;
                          resolve();
                        };
                        audio.play();
                      });
                    } else {
                      introPart2Promise = speakTextGCP(introText, false);
                    }
                  }

                  // ãƒ‘ãƒ¼ãƒˆ3ï¼š1è»’ç›® + 2è»’ç›®ä»¥é™ã‚’ä¸¦è¡Œã—ã¦éŸ³å£°åˆæˆé–‹å§‹
                  let firstShopAudioPromise: Promise<string | null> | null = null;
                  let remainingAudioPromise: Promise<string | null> | null = null;

                  if (shopLines.length > 0 && isTTSEnabled && isUserInteracted) {
                    const firstShop = shopLines[0];
                    const restShops = shopLines.slice(1).join('\n\n');

                    // â© 1è»’ç›®ã®éŸ³å£°åˆæˆã‚’å³åº§ã«é–‹å§‹ï¼ˆä¸¦è¡Œå‡¦ç†ï¼‰
                    const shopLangConfig = LANGUAGE_CODE_MAP[currentLanguage];
                    firstShopAudioPromise = (async () => {
                      const cleanText = stripMarkdown(firstShop);
                      const response = await fetch(`${apiBase}/api/tts/synthesize`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                          text: cleanText,
                          language_code: shopLangConfig.tts,
                          voice_name: shopLangConfig.voice
                        })
                      });
                      const result = await response.json();
                      return result.success ? `data:audio/mp3;base64,${result.audio}` : null;
                    })();

                    // â© 2è»’ç›®ä»¥é™ã‚‚åŒæ™‚ã«éŸ³å£°åˆæˆé–‹å§‹ï¼ˆä¸¦è¡Œå‡¦ç†ï¼‰
                    if (restShops) {
                      remainingAudioPromise = (async () => {
                        const cleanText = stripMarkdown(restShops);
                        const response = await fetch(`${apiBase}/api/tts/synthesize`, {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                            text: cleanText,
                            language_code: shopLangConfig.tts,
                            voice_name: shopLangConfig.voice
                          })
                        });
                        const result = await response.json();
                        return result.success ? `data:audio/mp3;base64,${result.audio}` : null;
                      })();
                    }
                  }

                  // ãƒ‘ãƒ¼ãƒˆ2ã®å†ç”Ÿå®Œäº†ã‚’å¾…ã¤
                  if (introPart2Promise) {
                    await introPart2Promise;
                  }

                  // 1è»’ç›®ã®éŸ³å£°åˆæˆå®Œäº†ã‚’å¾…ã£ã¦å†ç”Ÿ
                  if (firstShopAudioPromise) {
                    const firstShopAudio = await firstShopAudioPromise;
                    if (firstShopAudio) {
                      stopCurrentAudio();
                      const audio = new Audio(firstShopAudio);
                      currentAudio = audio;
                      // 1è»’ç›®ã®å†ç”Ÿå®Œäº†ã‚’å¾…ã¤
                      await new Promise<void>((resolve) => {
                        audio.onended = () => {
                          currentAudio = null;
                          voiceStatus.innerHTML = t('voiceStatusStopped');
                          voiceStatus.className = 'voice-status stopped';
                          resolve();
                        };

                        voiceStatus.innerHTML = t('voiceStatusSpeaking');
                        voiceStatus.className = 'voice-status speaking';

                        audio.play();
                      });

                      // 2è»’ç›®ä»¥é™ã®éŸ³å£°åˆæˆå®Œäº†ã‚’å¾…ã£ã¦å†ç”Ÿ
                      if (remainingAudioPromise) {
                        const remainingAudio = await remainingAudioPromise;
                        if (remainingAudio) {
                          await new Promise(resolve => setTimeout(resolve, 500));

                          stopCurrentAudio();
                          const audioElement = new Audio(remainingAudio);
                          currentAudio = audioElement;

                          await new Promise<void>((resolve) => {
                            audioElement.onended = () => {
                              currentAudio = null;
                              voiceStatus.innerHTML = 'ğŸ¤ éŸ³å£°èªè­˜: åœæ­¢ä¸­';
                              voiceStatus.className = 'voice-status stopped';
                              resolve();
                            };

                            voiceStatus.innerHTML = 'ğŸ”Š éŸ³å£°å†ç”Ÿä¸­...';
                            voiceStatus.className = 'voice-status speaking';

                            audioElement.play();
                          });
                        }
                      }
                    }
                  }
                } catch (error) {
                  console.error('[TTS] ã‚·ãƒ§ãƒƒãƒ—æƒ…å ±èª­ã¿ä¸Šã’ã‚¨ãƒ©ãƒ¼:', error);
                }
              })();
              // âœ… å³åº§ã«å®Ÿè¡Œã™ã‚‹ãŒã€å®Œäº†ã‚’å¾…ãŸãªã„
            } else {
              // ã‚·ãƒ§ãƒƒãƒ—ãªã—ã®é€šå¸¸ä¼šè©±ã¯å…¨æ–‡èª­ã¿ä¸Šã’
              speakTextGCP(data.response);
            }
          }
        }
      } catch (error) {
        console.error('é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
        // â˜…â˜…â˜… è¿½åŠ : ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚å‹•ç”»ã‚’ç¢ºå®Ÿã«æ¶ˆã™ â˜…â˜…â˜…
        hideWaitOverlay();
        showError('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
      } finally {
        isProcessing = false;
        sendBtn.disabled = false;
        micBtn.disabled = false;
        userInput.disabled = false;

        // ã‚·ãƒ§ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆã¯ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ãªã„
        if (currentShops.length === 0) {
          userInput.focus();
        } else {
          userInput.blur();
        }
      }
    }

    // äºˆç´„ä¾é ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
    function openReservationModal() {
      if (currentShops.length === 0) {
        showError(t('searchError'));
        return;
      }

      // ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ã¦ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
      const event = new CustomEvent('openReservationModal', {
        detail: { shops: currentShops }
      });
      document.dispatchEvent(event);
    }

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¿½åŠ 
    function addMessage(role: string, content: string, summary: string | null = null, isInitial: boolean = false) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${role}`;

      // åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å ´åˆã€data-initialå±æ€§ã‚’è¿½åŠ 
      if (isInitial) {
        messageDiv.setAttribute('data-initial', 'true');
      }

      const avatar = document.createElement('div');
      avatar.className = 'message-avatar';
      avatar.innerHTML = role === 'assistant' ? 'ğŸ½' : role === 'user' ? 'ğŸ‘¤' : 'âš ';

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ†ã‚­ã‚¹ãƒˆç”¨ã®spanè¦ç´ ã‚’ä½œæˆ
      const messageText = document.createElement('span');
      messageText.className = 'message-text';
      messageText.textContent = content;
      contentDiv.appendChild(messageText);

      messageDiv.appendChild(avatar);
      const wrapper = document.createElement('div');
      wrapper.appendChild(contentDiv);

      if (summary) {
        const summaryDiv = document.createElement('div');
        summaryDiv.className = 'summary-box';
        summaryDiv.innerHTML = `<strong>ğŸ“ å†…å®¹ç¢ºèª</strong>${summary}`;
        wrapper.appendChild(summaryDiv);
      }

      messageDiv.appendChild(wrapper);
      chatArea.appendChild(messageDiv);
      chatArea.scrollTop = chatArea.scrollHeight;
    }

    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
    function addLoadingMessage(): string {
      const id = 'loading-' + Date.now();
      const messageDiv = document.createElement('div');
      messageDiv.id = id;
      messageDiv.className = 'message assistant';

      const avatar = document.createElement('div');
      avatar.className = 'message-avatar';
      avatar.innerHTML = 'ğŸ½';

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.innerHTML = `
        <div class="loading"></div>
        <p style="margin-top: 8px; font-size: 13px; color: #6b7280;">
          ${t('loadingMessage')}
        </p>
      `;
      messageDiv.appendChild(avatar);
      messageDiv.appendChild(contentDiv);
      chatArea.appendChild(messageDiv);
      chatArea.scrollTop = chatArea.scrollHeight;

      return id;
    }

    function removeLoadingMessage(id: string) {
      const element = document.getElementById(id);
      if (element) element.remove();
    }

    // æœ€çµ‚è¦ç´„è¡¨ç¤º
    function showFinalSummary(summary: string) {
      const summaryDiv = document.createElement('div');
      summaryDiv.className = 'final-summary';
      summaryDiv.innerHTML = `
        <h3>${t('summaryTitle')}</h3>
        <div class="final-summary-content">${summary}</div>
        <p style="margin-top: 12px; font-size: 12px; color: #6b7280;">
          ${t('summaryFooter')}
        </p>
      `;
      chatArea.appendChild(summaryDiv);
      chatArea.scrollTop = chatArea.scrollHeight;
    }

    // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
    function showError(message: string) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      errorDiv.textContent = message;
      chatArea.appendChild(errorDiv);
      chatArea.scrollTop = chatArea.scrollHeight;
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    sendBtn.addEventListener('click', sendMessage);
    micBtn.addEventListener('click', toggleRecording);
    speakerBtn.addEventListener('click', toggleTTS);
    userInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
    reservationBtn.addEventListener('click', openReservationModal);
    // åˆæœŸåŒ–å®Ÿè¡Œ
    initialize();
  });
</script>